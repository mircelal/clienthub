function encodePath(path) {
  if (!path) {
    return path;
  }
  return path.split("/").map(encodeURIComponent).join("/");
}
function basename(path, extname2) {
  path = path.replace(/\\/g, "/").replace(/\/+$/g, "").replace(/.*\//, "");
  if (extname2 && extname2 !== path && path.endsWith(extname2)) {
    return path.substring(0, path.length - extname2.length);
  }
  return path;
}
function dirname(path) {
  path = path.replaceAll(/\\/g, "/");
  const sections = path.split("/");
  if (sections.length <= 1) {
    return ".";
  }
  sections.pop();
  if (sections.length === 1 && sections[0] === "") {
    return "/";
  }
  return sections.join("/");
}
function extname(path) {
  const base = basename(path);
  const index = base.lastIndexOf(".");
  if (index > 0) {
    return base.substring(index);
  }
  return "";
}
function join(...args) {
  if (arguments.length < 1) {
    return "";
  }
  const nonEmptyArgs = args.filter((arg) => arg.length > 0);
  if (nonEmptyArgs.length < 1) {
    return "";
  }
  const lastArg = nonEmptyArgs[nonEmptyArgs.length - 1];
  const leadingSlash = nonEmptyArgs[0].charAt(0) === "/";
  const trailingSlash = lastArg.charAt(lastArg.length - 1) === "/";
  const sections = nonEmptyArgs.reduce((acc, section) => acc.concat(section.split("/")), []);
  let first = !leadingSlash;
  const path = sections.reduce((acc, section) => {
    if (section === "") {
      return acc;
    }
    if (first) {
      first = false;
      return acc + section;
    }
    return acc + "/" + section;
  }, "");
  if (trailingSlash) {
    return path + "/";
  }
  return path;
}
function isSamePath(path1, path2) {
  const pathSections1 = (path1 || "").split("/").filter((p) => p !== ".");
  const pathSections2 = (path2 || "").split("/").filter((p) => p !== ".");
  path1 = join(...pathSections1);
  path2 = join(...pathSections2);
  return path1 === path2;
}
export {
  basename,
  dirname,
  encodePath,
  extname,
  isSamePath,
  join
};
//# sourceMappingURL=index.mjs.map
