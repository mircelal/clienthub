declare const _default: import('vue').DefineComponent<import('vue').ExtractPropTypes<{
    /**
     * Set a custom url to the avatar image
     * either the url, user or displayName property must be defined
     */
    url: {
        type: StringConstructor;
        default: undefined;
    };
    /**
     * Set a css icon-class for an icon to be used instead of the avatar.
     */
    iconClass: {
        type: StringConstructor;
        default: undefined;
    };
    /**
     * Set the user id to fetch the avatar
     * either the url, user or displayName property must be defined
     */
    user: {
        type: StringConstructor;
        default: undefined;
    };
    /**
     * Do not show the user status on the avatar.
     */
    hideStatus: {
        type: BooleanConstructor;
        default: boolean;
    };
    /**
     * Show the verbose user status (e.g. "online" / "away") instead of just the status icon.
     */
    verboseStatus: {
        type: BooleanConstructor;
        default: boolean;
    };
    /**
     * When the user status was preloaded via another source it can be handed in with this property to save the request.
     * If this property is not set the status will be fetched automatically.
     * If a preloaded no-status is available provide this object with properties "status", "icon" and "message" set to null.
     */
    preloadedUserStatus: {
        type: ObjectConstructor;
        default: undefined;
    };
    /**
     * Is the user a guest user (then we have to user a different endpoint)
     */
    isGuest: {
        type: BooleanConstructor;
        default: boolean;
    };
    /**
     * Set a display name that will be rendered as a tooltip
     * either the url, user or displayName property must be defined
     * specify just the displayname to generate a placeholder avatar without
     * trying to fetch the avatar based on the user id
     */
    displayName: {
        type: StringConstructor;
        default: undefined;
    };
    /**
     * Set a size in px for the rendered avatar
     */
    size: {
        type: NumberConstructor;
        default: number;
    };
    /**
     * Do not automatically generate a placeholder avatars if there is no real avatar is available.
     */
    noPlaceholder: {
        type: BooleanConstructor;
        default: boolean;
    };
    /**
     * Disable the tooltip
     */
    disableTooltip: {
        type: BooleanConstructor;
        default: boolean;
    };
    /**
     * Disable the menu
     */
    disableMenu: {
        type: BooleanConstructor;
        default: boolean;
    };
    /**
     * Declares a custom tooltip when not null
     * Fallback will be the displayName
     *
     * requires disableTooltip not to be set to true
     */
    tooltipMessage: {
        type: StringConstructor;
        default: null;
    };
    /**
     * Declares username is not a user's name, when true.
     * Prevents loading user's avatar from server and forces generating colored initials,
     * i.e. if the user is a group
     */
    isNoUser: {
        type: BooleanConstructor;
        default: boolean;
    };
    /**
     * Selector for the popover menu container
     */
    menuContainer: {
        type: (ObjectConstructor | BooleanConstructor | StringConstructor | {
            new (): Element;
            prototype: Element;
        })[];
        default: string;
    };
}>, {
    isDarkTheme: Readonly<import('vue').Ref<boolean, boolean>>;
}, {
    avatarUrlLoaded: null;
    avatarSrcSetLoaded: null;
    userDoesNotExist: boolean;
    isAvatarLoaded: boolean;
    isMenuLoaded: boolean;
    contactsMenuLoading: boolean;
    contactsMenuData: {};
    contactsMenuActions: never[];
    contactsMenuOpenState: boolean;
}, {
    avatarAriaLabel(): string | undefined;
    canDisplayUserStatus(): boolean;
    showUserStatusIconOnAvatar(): false | null;
    /**
     * The user identifier, either the display name if set or the user property
     * If both properties are not set an empty string is returned
     */
    userIdentifier(): string | undefined;
    isUserDefined(): boolean;
    isDisplayNameDefined(): boolean;
    isUrlDefined(): boolean;
    hasMenu(): boolean;
    /**
     * True if initials should be shown as the user icon fallback
     */
    showInitials(): boolean;
    avatarStyle(): {
        '--avatar-size': string;
        lineHeight: string | number;
        fontSize: string;
    };
    initialsWrapperStyle(): {
        backgroundColor: string;
    };
    initialsStyle(): {
        color: string;
    };
    tooltip(): string | null | undefined;
    /**
     * Get the (max. two) initials of the user as uppcase string
     */
    initials(): string;
    menu(): {
        ncActionComponent: import('vue').DefineComponent<{}, {}, {}, {}, {}, {
            mixins: {
                beforeUpdate(): void;
                data(): {
                    text: any;
                };
                computed: {
                    isLongText(): any;
                };
                methods: {
                    getText(): any;
                };
            }[];
            props: {
                icon: {
                    type: StringConstructor;
                    default: string;
                };
                name: {
                    type: StringConstructor;
                    default: string;
                };
                title: {
                    type: StringConstructor;
                    default: string;
                };
                closeAfterClick: {
                    type: BooleanConstructor;
                    default: boolean;
                };
                ariaLabel: {
                    type: StringConstructor;
                    default: null;
                };
            };
            inject: {
                closeMenu: {
                    from: import('vue').InjectionKey<(returnFocus: boolean) => void>;
                };
            };
            emits: string[];
            created(): void;
            computed: {
                isIconUrl(): boolean;
            };
            methods: {
                onClick(event: any): void;
            };
        }, import('vue').ComponentOptionsMixin, {}, string, import('vue').PublicProps, Readonly<{}> & Readonly<{}>, {}, {}, {}, {}, string, import('vue').ComponentProvideOptions, true, {}, any>;
        ncActionComponentProps: {};
        iconSvg: string | undefined;
        text: string;
    }[] | {
        ncActionComponent: import('vue').DefineSetupFnComponent<Record<string, any>, {}, {}, Record<string, any> & {}, import('vue').PublicProps> | import('vue').DefineComponent<import('vue').ExtractPropTypes<{
            to: {
                type: (ObjectConstructor | StringConstructor)[];
                required: true;
            };
        }>, {}, {}, {}, {}, {
            mixins: {
                beforeUpdate(): void;
                data(): {
                    text: any;
                };
                computed: {
                    isLongText(): any;
                };
                methods: {
                    getText(): any;
                };
            }[];
            props: {
                icon: {
                    type: StringConstructor;
                    default: string;
                };
                name: {
                    type: StringConstructor;
                    default: string;
                };
                title: {
                    type: StringConstructor;
                    default: string;
                };
                closeAfterClick: {
                    type: BooleanConstructor;
                    default: boolean;
                };
                ariaLabel: {
                    type: StringConstructor;
                    default: null;
                };
            };
            inject: {
                closeMenu: {
                    from: import('vue').InjectionKey<(returnFocus: boolean) => void>;
                };
            };
            emits: string[];
            created(): void;
            computed: {
                isIconUrl(): boolean;
            };
            methods: {
                onClick(event: any): void;
            };
        }, import('vue').ComponentOptionsMixin, {}, string, import('vue').PublicProps, Readonly<import('vue').ExtractPropTypes<{
            to: {
                type: (ObjectConstructor | StringConstructor)[];
                required: true;
            };
        }>> & Readonly<{}>, {}, {}, {}, {}, string, import('vue').ComponentProvideOptions, true, {}, any>;
        ncActionComponentProps: {
            to: string;
            icon: any;
            href?: undefined;
        } | {
            href: any;
            icon: any;
            to?: undefined;
        };
        text: any;
    }[];
}, {
    t: (original: string, placeholders?: Record<string, string | number>) => string;
    handleUserStatusUpdated(state: any): void;
    /**
     * Toggle the popover menu on click or enter
     *
     * @param {KeyboardEvent|MouseEvent} event the UI event
     */
    toggleMenu(event: KeyboardEvent | MouseEvent): Promise<void>;
    closeMenu(): void;
    fetchContactsMenu(): Promise<void>;
    /**
     * Handle avatar loading if user or url defined
     */
    loadAvatarUrl(): void;
    /**
     * Generate an avatar url from the server's avatar endpoint
     *
     * @param {string} user the user id
     * @param {number} size the desired size
     * @return {string}
     */
    avatarUrlGenerator(user: string, size: number): string;
    /**
     * Check if the provided url is valid and update Avatar if so
     *
     * @param {string} url the avatar url
     * @param {Array} srcset the avatar srcset
     */
    updateImageIfValid(url: string, srcset?: any[]): void;
}, {
    data(): {
        hasStatus: boolean;
        userStatus: {
            status: null;
            message: null;
            icon: null;
        };
    };
    methods: {
        fetchUserStatus(userId: string): Promise<void>;
        setUserStatus({ status, message, icon }: string): void;
    };
}, import('vue').ComponentOptionsMixin, {}, string, import('vue').PublicProps, Readonly<import('vue').ExtractPropTypes<{
    /**
     * Set a custom url to the avatar image
     * either the url, user or displayName property must be defined
     */
    url: {
        type: StringConstructor;
        default: undefined;
    };
    /**
     * Set a css icon-class for an icon to be used instead of the avatar.
     */
    iconClass: {
        type: StringConstructor;
        default: undefined;
    };
    /**
     * Set the user id to fetch the avatar
     * either the url, user or displayName property must be defined
     */
    user: {
        type: StringConstructor;
        default: undefined;
    };
    /**
     * Do not show the user status on the avatar.
     */
    hideStatus: {
        type: BooleanConstructor;
        default: boolean;
    };
    /**
     * Show the verbose user status (e.g. "online" / "away") instead of just the status icon.
     */
    verboseStatus: {
        type: BooleanConstructor;
        default: boolean;
    };
    /**
     * When the user status was preloaded via another source it can be handed in with this property to save the request.
     * If this property is not set the status will be fetched automatically.
     * If a preloaded no-status is available provide this object with properties "status", "icon" and "message" set to null.
     */
    preloadedUserStatus: {
        type: ObjectConstructor;
        default: undefined;
    };
    /**
     * Is the user a guest user (then we have to user a different endpoint)
     */
    isGuest: {
        type: BooleanConstructor;
        default: boolean;
    };
    /**
     * Set a display name that will be rendered as a tooltip
     * either the url, user or displayName property must be defined
     * specify just the displayname to generate a placeholder avatar without
     * trying to fetch the avatar based on the user id
     */
    displayName: {
        type: StringConstructor;
        default: undefined;
    };
    /**
     * Set a size in px for the rendered avatar
     */
    size: {
        type: NumberConstructor;
        default: number;
    };
    /**
     * Do not automatically generate a placeholder avatars if there is no real avatar is available.
     */
    noPlaceholder: {
        type: BooleanConstructor;
        default: boolean;
    };
    /**
     * Disable the tooltip
     */
    disableTooltip: {
        type: BooleanConstructor;
        default: boolean;
    };
    /**
     * Disable the menu
     */
    disableMenu: {
        type: BooleanConstructor;
        default: boolean;
    };
    /**
     * Declares a custom tooltip when not null
     * Fallback will be the displayName
     *
     * requires disableTooltip not to be set to true
     */
    tooltipMessage: {
        type: StringConstructor;
        default: null;
    };
    /**
     * Declares username is not a user's name, when true.
     * Prevents loading user's avatar from server and forces generating colored initials,
     * i.e. if the user is a group
     */
    isNoUser: {
        type: BooleanConstructor;
        default: boolean;
    };
    /**
     * Selector for the popover menu container
     */
    menuContainer: {
        type: (ObjectConstructor | BooleanConstructor | StringConstructor | {
            new (): Element;
            prototype: Element;
        })[];
        default: string;
    };
}>> & Readonly<{}>, {
    size: number;
    displayName: string;
    url: string;
    user: string;
    iconClass: string;
    hideStatus: boolean;
    verboseStatus: boolean;
    preloadedUserStatus: Record<string, any>;
    isGuest: boolean;
    noPlaceholder: boolean;
    disableTooltip: boolean;
    disableMenu: boolean;
    tooltipMessage: string;
    isNoUser: boolean;
    menuContainer: string | boolean | Element | Record<string, any>;
}, {}, {
    IconDotsHorizontal: any;
    NcActions: import('vue').DefineComponent<import('vue').ExtractPropTypes<{
        open: {
            type: BooleanConstructor;
            default: boolean;
        };
        manualOpen: {
            type: BooleanConstructor;
            default: boolean;
        };
        forceMenu: {
            type: BooleanConstructor;
            default: boolean;
        };
        forceName: {
            type: BooleanConstructor;
            default: boolean;
        };
        menuName: {
            type: StringConstructor;
            default: null;
        };
        primary: {
            type: BooleanConstructor;
            default: boolean;
        };
        defaultIcon: {
            type: StringConstructor;
            default: string;
        };
        ariaLabel: {
            type: StringConstructor;
            default: string;
        };
        placement: {
            type: StringConstructor;
            default: string;
        };
        boundariesElement: {
            type: {
                new (): Element;
                prototype: Element;
            };
            default: () => HTMLElement | null;
        };
        container: {
            type: (ObjectConstructor | BooleanConstructor | StringConstructor | {
                new (): Element;
                prototype: Element;
            })[];
            default: string;
        };
        disabled: {
            type: BooleanConstructor;
            default: boolean;
        };
        inline: {
            type: NumberConstructor;
            default: number;
        };
        variant: {
            type: StringConstructor;
            validator(value: unknown): boolean;
            default: null;
        };
        size: {
            type: StringConstructor;
            default: string;
            validator(value: unknown): boolean;
        };
    }>, {
        randomId: string;
    }, {
        opened: boolean;
        focusIndex: number;
        actionsMenuSemanticType: "menu" | "navigation" | "dialog" | "tooltip" | "unknown";
    }, {
        triggerButtonVariant(): string;
        config(): {
            popupRole: string;
            withArrowNavigation: boolean;
            withTabNavigation: boolean;
            withFocusTrap: boolean;
        } | {
            popupRole: undefined;
            withArrowNavigation: boolean;
            withTabNavigation: boolean;
            withFocusTrap: boolean;
        } | {
            popupRole: string;
            withArrowNavigation: boolean;
            withTabNavigation: boolean;
            withFocusTrap: boolean;
        } | {
            popupRole: undefined;
            withArrowNavigation: boolean;
            withTabNavigation: boolean;
            withFocusTrap: boolean;
        } | {
            popupRole: undefined;
            role: undefined;
            withArrowNavigation: boolean;
            withTabNavigation: boolean;
            withFocusTrap: boolean;
        };
        withFocusTrap(): boolean;
    }, {
        getActionName(action: import('vue').VNode): string;
        isValidSingleAction(action: import('vue').VNode): boolean;
        isAction(action: any): boolean;
        isIconUrl(url: string): boolean;
        toggleMenu(state: any): void;
        openMenu(): void;
        closeMenu(returnFocus?: boolean): Promise<void>;
        onOpened(): void;
        onClosed(): void;
        getCurrentActiveMenuItemElement(): HTMLElement | null;
        getFocusableMenuItemElements(): NodeList<HTMLElement>;
        onKeydown(event: object): void;
        onTriggerKeydown(event: any): void;
        handleEscapePressed(event: any): void;
        removeCurrentActive(): void;
        focusAction(): void;
        focusPreviousAction(event: any): void;
        focusNextAction(event: any): void;
        focusFirstAction(event: any): void;
        focusLastAction(event: any): void;
        preventIfEvent(event: any): void;
        onFocus(event: any): void;
        onBlur(event: any): void;
        onClick(event: any): void;
    }, import('vue').ComponentOptionsMixin, import('vue').ComponentOptionsMixin, ("blur" | "click" | "close" | "focus" | "open" | "closed" | "opened" | "update:open")[], "blur" | "click" | "close" | "focus" | "open" | "closed" | "opened" | "update:open", import('vue').PublicProps, Readonly<import('vue').ExtractPropTypes<{
        open: {
            type: BooleanConstructor;
            default: boolean;
        };
        manualOpen: {
            type: BooleanConstructor;
            default: boolean;
        };
        forceMenu: {
            type: BooleanConstructor;
            default: boolean;
        };
        forceName: {
            type: BooleanConstructor;
            default: boolean;
        };
        menuName: {
            type: StringConstructor;
            default: null;
        };
        primary: {
            type: BooleanConstructor;
            default: boolean;
        };
        defaultIcon: {
            type: StringConstructor;
            default: string;
        };
        ariaLabel: {
            type: StringConstructor;
            default: string;
        };
        placement: {
            type: StringConstructor;
            default: string;
        };
        boundariesElement: {
            type: {
                new (): Element;
                prototype: Element;
            };
            default: () => HTMLElement | null;
        };
        container: {
            type: (ObjectConstructor | BooleanConstructor | StringConstructor | {
                new (): Element;
                prototype: Element;
            })[];
            default: string;
        };
        disabled: {
            type: BooleanConstructor;
            default: boolean;
        };
        inline: {
            type: NumberConstructor;
            default: number;
        };
        variant: {
            type: StringConstructor;
            validator(value: unknown): boolean;
            default: null;
        };
        size: {
            type: StringConstructor;
            default: string;
            validator(value: unknown): boolean;
        };
    }>> & Readonly<{
        onFocus?: ((...args: any[]) => any) | undefined;
        onBlur?: ((...args: any[]) => any) | undefined;
        onClick?: ((...args: any[]) => any) | undefined;
        onClose?: ((...args: any[]) => any) | undefined;
        onOpen?: ((...args: any[]) => any) | undefined;
        onClosed?: ((...args: any[]) => any) | undefined;
        onOpened?: ((...args: any[]) => any) | undefined;
        "onUpdate:open"?: ((...args: any[]) => any) | undefined;
    }>, {
        size: string;
        disabled: boolean;
        open: boolean;
        primary: boolean;
        ariaLabel: string;
        variant: string;
        inline: number;
        placement: string;
        container: string | boolean | Element | Record<string, any>;
        manualOpen: boolean;
        forceMenu: boolean;
        forceName: boolean;
        menuName: string;
        defaultIcon: string;
        boundariesElement: Element;
    }, {}, {
        NcButton: {
            new (...args: any[]): import('vue').CreateComponentPublicInstanceWithMixins<Readonly<{
                alignment?: import('../NcButton/NcButton.vue').ButtonAlignment;
                ariaLabel?: string;
                disabled?: boolean;
                download?: string | true;
                href?: string;
                pressed?: boolean | undefined;
                size?: import('../NcButton/NcButton.vue').ButtonSize;
                target?: string;
                text?: string;
                to?: import('vue-router').RouteLocationRaw;
                type?: import('../NcButton/NcButton.vue').ButtonType;
                variant?: import('../NcButton/NcButton.vue').ButtonVariant;
                wide?: boolean;
            }> & Readonly<{
                onClick?: ((e: MouseEvent) => any) | undefined;
                "onUpdate:pressed"?: ((pressed: boolean) => any) | undefined;
            }>, {}, {}, {}, {}, import('vue').ComponentOptionsMixin, import('vue').ComponentOptionsMixin, {
                click: (e: MouseEvent) => any;
                "update:pressed": (pressed: boolean) => any;
            }, import('vue').PublicProps, {
                size: import('../NcButton/NcButton.vue').ButtonSize;
                type: import('../NcButton/NcButton.vue').ButtonType;
                text: string;
                alignment: import('../NcButton/NcButton.vue').ButtonAlignment;
                ariaLabel: string;
                download: string | true;
                href: string;
                pressed: boolean;
                target: string;
                to: import('vue-router').RouteLocationRaw;
                variant: import('../NcButton/NcButton.vue').ButtonVariant;
            }, false, {}, {}, import('vue').GlobalComponents, import('vue').GlobalDirectives, string, {}, any, import('vue').ComponentProvideOptions, {
                P: {};
                B: {};
                D: {};
                C: {};
                M: {};
                Defaults: {};
            }, Readonly<{
                alignment?: import('../NcButton/NcButton.vue').ButtonAlignment;
                ariaLabel?: string;
                disabled?: boolean;
                download?: string | true;
                href?: string;
                pressed?: boolean | undefined;
                size?: import('../NcButton/NcButton.vue').ButtonSize;
                target?: string;
                text?: string;
                to?: import('vue-router').RouteLocationRaw;
                type?: import('../NcButton/NcButton.vue').ButtonType;
                variant?: import('../NcButton/NcButton.vue').ButtonVariant;
                wide?: boolean;
            }> & Readonly<{
                onClick?: ((e: MouseEvent) => any) | undefined;
                "onUpdate:pressed"?: ((pressed: boolean) => any) | undefined;
            }>, {}, {}, {}, {}, {
                size: import('../NcButton/NcButton.vue').ButtonSize;
                type: import('../NcButton/NcButton.vue').ButtonType;
                text: string;
                alignment: import('../NcButton/NcButton.vue').ButtonAlignment;
                ariaLabel: string;
                download: string | true;
                href: string;
                pressed: boolean;
                target: string;
                to: import('vue-router').RouteLocationRaw;
                variant: import('../NcButton/NcButton.vue').ButtonVariant;
            }>;
            __isFragment?: never;
            __isTeleport?: never;
            __isSuspense?: never;
        } & import('vue').ComponentOptionsBase<Readonly<{
            alignment?: import('../NcButton/NcButton.vue').ButtonAlignment;
            ariaLabel?: string;
            disabled?: boolean;
            download?: string | true;
            href?: string;
            pressed?: boolean | undefined;
            size?: import('../NcButton/NcButton.vue').ButtonSize;
            target?: string;
            text?: string;
            to?: import('vue-router').RouteLocationRaw;
            type?: import('../NcButton/NcButton.vue').ButtonType;
            variant?: import('../NcButton/NcButton.vue').ButtonVariant;
            wide?: boolean;
        }> & Readonly<{
            onClick?: ((e: MouseEvent) => any) | undefined;
            "onUpdate:pressed"?: ((pressed: boolean) => any) | undefined;
        }>, {}, {}, {}, {}, import('vue').ComponentOptionsMixin, import('vue').ComponentOptionsMixin, {
            click: (e: MouseEvent) => any;
            "update:pressed": (pressed: boolean) => any;
        }, string, {
            size: import('../NcButton/NcButton.vue').ButtonSize;
            type: import('../NcButton/NcButton.vue').ButtonType;
            text: string;
            alignment: import('../NcButton/NcButton.vue').ButtonAlignment;
            ariaLabel: string;
            download: string | true;
            href: string;
            pressed: boolean;
            target: string;
            to: import('vue-router').RouteLocationRaw;
            variant: import('../NcButton/NcButton.vue').ButtonVariant;
        }, {}, string, {}, import('vue').GlobalComponents, import('vue').GlobalDirectives, string, import('vue').ComponentProvideOptions> & import('vue').VNodeProps & import('vue').AllowedComponentProps & import('vue').ComponentCustomProps & (new () => {
            $slots: Readonly<{
                default?: import('vue').Slot;
                icon?: import('vue').Slot;
            }> & {
                default?: import('vue').Slot;
                icon?: import('vue').Slot;
            };
        });
        NcPopover: import('vue').DefineSetupFnComponent<Record<string, any>, {}, {}, Record<string, any> & {}, import('vue').PublicProps>;
    }, {}, string, () => {
        [x: symbol]: import('vue').ComputedRef<boolean> | ((returnFocus?: boolean) => Promise<void>);
    }, true, {}, any>;
    NcButton: {
        new (...args: any[]): import('vue').CreateComponentPublicInstanceWithMixins<Readonly<{
            alignment?: import('../NcButton/NcButton.vue').ButtonAlignment;
            ariaLabel?: string;
            disabled?: boolean;
            download?: string | true;
            href?: string;
            pressed?: boolean | undefined;
            size?: import('../NcButton/NcButton.vue').ButtonSize;
            target?: string;
            text?: string;
            to?: import('vue-router').RouteLocationRaw;
            type?: import('../NcButton/NcButton.vue').ButtonType;
            variant?: import('../NcButton/NcButton.vue').ButtonVariant;
            wide?: boolean;
        }> & Readonly<{
            onClick?: ((e: MouseEvent) => any) | undefined;
            "onUpdate:pressed"?: ((pressed: boolean) => any) | undefined;
        }>, {}, {}, {}, {}, import('vue').ComponentOptionsMixin, import('vue').ComponentOptionsMixin, {
            click: (e: MouseEvent) => any;
            "update:pressed": (pressed: boolean) => any;
        }, import('vue').PublicProps, {
            size: import('../NcButton/NcButton.vue').ButtonSize;
            type: import('../NcButton/NcButton.vue').ButtonType;
            text: string;
            alignment: import('../NcButton/NcButton.vue').ButtonAlignment;
            ariaLabel: string;
            download: string | true;
            href: string;
            pressed: boolean;
            target: string;
            to: import('vue-router').RouteLocationRaw;
            variant: import('../NcButton/NcButton.vue').ButtonVariant;
        }, false, {}, {}, import('vue').GlobalComponents, import('vue').GlobalDirectives, string, {}, any, import('vue').ComponentProvideOptions, {
            P: {};
            B: {};
            D: {};
            C: {};
            M: {};
            Defaults: {};
        }, Readonly<{
            alignment?: import('../NcButton/NcButton.vue').ButtonAlignment;
            ariaLabel?: string;
            disabled?: boolean;
            download?: string | true;
            href?: string;
            pressed?: boolean | undefined;
            size?: import('../NcButton/NcButton.vue').ButtonSize;
            target?: string;
            text?: string;
            to?: import('vue-router').RouteLocationRaw;
            type?: import('../NcButton/NcButton.vue').ButtonType;
            variant?: import('../NcButton/NcButton.vue').ButtonVariant;
            wide?: boolean;
        }> & Readonly<{
            onClick?: ((e: MouseEvent) => any) | undefined;
            "onUpdate:pressed"?: ((pressed: boolean) => any) | undefined;
        }>, {}, {}, {}, {}, {
            size: import('../NcButton/NcButton.vue').ButtonSize;
            type: import('../NcButton/NcButton.vue').ButtonType;
            text: string;
            alignment: import('../NcButton/NcButton.vue').ButtonAlignment;
            ariaLabel: string;
            download: string | true;
            href: string;
            pressed: boolean;
            target: string;
            to: import('vue-router').RouteLocationRaw;
            variant: import('../NcButton/NcButton.vue').ButtonVariant;
        }>;
        __isFragment?: never;
        __isTeleport?: never;
        __isSuspense?: never;
    } & import('vue').ComponentOptionsBase<Readonly<{
        alignment?: import('../NcButton/NcButton.vue').ButtonAlignment;
        ariaLabel?: string;
        disabled?: boolean;
        download?: string | true;
        href?: string;
        pressed?: boolean | undefined;
        size?: import('../NcButton/NcButton.vue').ButtonSize;
        target?: string;
        text?: string;
        to?: import('vue-router').RouteLocationRaw;
        type?: import('../NcButton/NcButton.vue').ButtonType;
        variant?: import('../NcButton/NcButton.vue').ButtonVariant;
        wide?: boolean;
    }> & Readonly<{
        onClick?: ((e: MouseEvent) => any) | undefined;
        "onUpdate:pressed"?: ((pressed: boolean) => any) | undefined;
    }>, {}, {}, {}, {}, import('vue').ComponentOptionsMixin, import('vue').ComponentOptionsMixin, {
        click: (e: MouseEvent) => any;
        "update:pressed": (pressed: boolean) => any;
    }, string, {
        size: import('../NcButton/NcButton.vue').ButtonSize;
        type: import('../NcButton/NcButton.vue').ButtonType;
        text: string;
        alignment: import('../NcButton/NcButton.vue').ButtonAlignment;
        ariaLabel: string;
        download: string | true;
        href: string;
        pressed: boolean;
        target: string;
        to: import('vue-router').RouteLocationRaw;
        variant: import('../NcButton/NcButton.vue').ButtonVariant;
    }, {}, string, {}, import('vue').GlobalComponents, import('vue').GlobalDirectives, string, import('vue').ComponentProvideOptions> & import('vue').VNodeProps & import('vue').AllowedComponentProps & import('vue').ComponentCustomProps & (new () => {
        $slots: Readonly<{
            default?: import('vue').Slot;
            icon?: import('vue').Slot;
        }> & {
            default?: import('vue').Slot;
            icon?: import('vue').Slot;
        };
    });
    NcIconSvgWrapper: import('vue').DefineComponent<{
        directional?: boolean;
        inline?: boolean;
        svg?: string;
        name?: string;
        path?: string;
        size?: number | "auto";
    }, {}, {}, {}, {}, import('vue').ComponentOptionsMixin, import('vue').ComponentOptionsMixin, {}, string, import('vue').PublicProps, Readonly<{
        directional?: boolean;
        inline?: boolean;
        svg?: string;
        name?: string;
        path?: string;
        size?: number | "auto";
    }> & Readonly<{}>, {
        size: number | "auto";
        name: string;
        svg: string;
        path: string;
    }, {}, {}, {}, string, import('vue').ComponentProvideOptions, false, {}, HTMLSpanElement>;
    NcLoadingIcon: import('vue').DefineComponent<{
        appearance?: "auto" | "light" | "dark";
        name?: string;
        size?: number;
    }, {}, {}, {}, {}, import('vue').ComponentOptionsMixin, import('vue').ComponentOptionsMixin, {}, string, import('vue').PublicProps, Readonly<{
        appearance?: "auto" | "light" | "dark";
        name?: string;
        size?: number;
    }> & Readonly<{}>, {
        size: number;
        name: string;
        appearance: "auto" | "light" | "dark";
    }, {}, {}, {}, string, import('vue').ComponentProvideOptions, false, {}, HTMLSpanElement>;
    NcUserStatusIcon: import('vue').DefineComponent<{
        status?: "online" | "away" | "busy" | "dnd" | "invisible" | "offline";
    } & {
        user?: string;
        ariaHidden?: boolean | "true" | "false";
    }, {}, {}, {}, {}, import('vue').ComponentOptionsMixin, import('vue').ComponentOptionsMixin, {
        "update:status": (value: "offline" | "online" | "invisible" | "away" | "busy" | "dnd") => any;
    }, string, import('vue').PublicProps, Readonly<{
        status?: "online" | "away" | "busy" | "dnd" | "invisible" | "offline";
    } & {
        user?: string;
        ariaHidden?: boolean | "true" | "false";
    }> & Readonly<{
        "onUpdate:status"?: ((value: "offline" | "online" | "invisible" | "away" | "busy" | "dnd") => any) | undefined;
    }>, {
        ariaHidden: boolean | "true" | "false";
        user: string;
    }, {}, {}, {}, string, import('vue').ComponentProvideOptions, false, {}, any>;
}, {
    /** @type {import('vue').ObjectDirective} */
    ClickOutside: import('vue').ObjectDirective;
}, string, import('vue').ComponentProvideOptions, true, {}, any>;
export default _default;
