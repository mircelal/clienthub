export interface UseHotKeyOptions {
    /** Make key filter case sensitive */
    caseSensitive?: boolean;
    /** Prevent default behavior of key stroke */
    prevent?: boolean;
    /** Stop the event bubbling */
    stop?: boolean;
    /** Also listen for keyup event */
    push?: boolean;
    /**
     * If set then the callback is only called when the shift key is (not) pressed.
     * When left `undefined` a pressed shift key is ignored (callback is run with and without shift pressed).
     */
    shift?: boolean;
    /**
     * Only run the callback if the control key is (not-)pressed.
     * Undefined will be handled the same as `false` and will only run the callback if the 'ctrl' key is NOT pressed.
     */
    ctrl?: boolean;
    /**
     * If set the callback is only executed if the alt key is (not-)pressed
     * Undefined will be handled the same as `false` and will only run the callback if the 'alt' key is NOT pressed.
     */
    alt?: boolean;
    /**
     * Allow hot key to trigger even if a modal/dialog is open.
     * By default this is disabled to not trigger hot keys in apps if they are overlaid by a modal/dialog.
     *
     * @default false
     */
    allowInModal?: boolean;
}
type KeyboardEventHandler = (event: KeyboardEvent) => void;
/**
 * Composable to use keyboard shortcuts in the application.
 * It respects the users accessibility configuration (opt-out shortcuts).
 *
 * @param keysOrFilter - keyboard key(s) to listen to, or filter function or pass `true` for listening to all keys
 * @param callback - callback function
 * @param options - composable options
 * @see docs/composables/useHotKey.md
 */
export declare function useHotKey(keysOrFilter: true | string | string[] | ((e: KeyboardEvent) => boolean), callback?: KeyboardEventHandler, options?: UseHotKeyOptions): () => void;
export {};
