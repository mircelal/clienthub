{"version":3,"file":"NcHighlight.vue_vue_type_script_lang-DnWQDM_2.mjs","sources":["../../src/utils/findRanges.ts","../../src/components/NcHighlight/NcHighlight.vue"],"sourcesContent":["/*!\n * SPDX-FileCopyrightText: 2020 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n\nexport interface StringRange {\n\tstart: number\n\tend: number\n}\n\n/**\n * Find the ranges of a substr in a given string\n *\n * @param text - The text to search in\n * @param search - The text to search for\n * @return The array of ranges to highlight\n */\nexport function findRanges(text: string, search: string): StringRange[] {\n\tconst ranges: StringRange[] = []\n\n\tlet currentIndex = 0\n\tlet index = text.toLowerCase().indexOf(search.toLowerCase(), currentIndex)\n\t// Variable to track that we don't iterate more often than the length of the text.\n\t// Shouldn't happen anyway, but just to be sure to not hang the browser for some reason.\n\tlet i = 0\n\twhile (index > -1 && i++ < text.length) {\n\t\tcurrentIndex = index + search.length\n\t\tranges.push({ start: index, end: currentIndex })\n\n\t\tindex = text.toLowerCase().indexOf(search.toLowerCase(), currentIndex)\n\t}\n\treturn ranges\n}\n","<!--\n  - SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors\n  - SPDX-License-Identifier: AGPL-3.0-or-later\n-->\n\n<docs>\n\n### General description\n\nHighlight a string with html &lt;strong&gt;. Accepts a substring to highlight or an array with ranges.\n\n### Usage\n\n```vue\n<template>\n\t<div>\n\t\t<NcHighlight text=\"Highlight me please!\" search=\"me\" />\n\t\t<br />\n\t\t<NcHighlight text=\"Highlight me please!\" :highlight=\"[{ start: 4, end: 12 }]\" />\n\t</div>\n</template>\n```\n</docs>\n\n<script lang=\"ts\">\nimport type { PropType } from 'vue'\nimport type { StringRange } from '../../utils/findRanges.ts'\n\nimport { defineComponent, h } from 'vue'\nimport { findRanges } from '../../utils/findRanges.ts'\n\n/**\n * Represents one chunk of the input text\n */\nexport interface HighlightChunk extends StringRange {\n\thighlight: boolean\n\ttext: string\n}\n\nexport default defineComponent({\n\tname: 'NcHighlight',\n\tprops: {\n\t\t/**\n\t\t * The string to display\n\t\t */\n\t\ttext: {\n\t\t\ttype: String,\n\t\t\tdefault: '',\n\t\t},\n\n\t\t/**\n\t\t * The string to match and highlight\n\t\t */\n\t\tsearch: {\n\t\t\ttype: String,\n\t\t\tdefault: '',\n\t\t},\n\n\t\t/**\n\t\t * The ranges to highlight, takes precedence over the search prop.\n\t\t */\n\t\thighlight: {\n\t\t\ttype: Array as PropType<StringRange[]>,\n\t\t\tdefault: () => [],\n\t\t},\n\t},\n\n\tcomputed: {\n\t\t/**\n\t\t * The indice ranges which should be highlighted.\n\t\t * If an array with ranges is provided, we use it. Otherwise\n\t\t * we calculate it based on the provided substring to highlight.\n\t\t *\n\t\t * @return The array of ranges to highlight\n\t\t */\n\t\tranges(): StringRange[] {\n\t\t\tlet ranges: StringRange[] = []\n\t\t\t// If the search term and the highlight array is empty, return early with empty array\n\t\t\tif (!this.search && this.highlight.length === 0) {\n\t\t\t\treturn ranges\n\t\t\t}\n\n\t\t\t// If there are ranges to highlight provided, we use this array.\n\t\t\tif (this.highlight.length > 0) {\n\t\t\t\tranges = this.highlight\n\t\t\t// Otherwise we check the text to highlight for matches of the search term.\n\t\t\t} else {\n\t\t\t\tranges = findRanges(this.text, this.search)\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Ensure that the start of each range is equal to or smaller than the end\n\t\t\t */\n\t\t\tranges.forEach((range, i) => {\n\t\t\t\tif (range.end < range.start) {\n\t\t\t\t\tranges[i] = {\n\t\t\t\t\t\tstart: range.end,\n\t\t\t\t\t\tend: range.start,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\n\t\t\t/**\n\t\t\t * Validate the ranges array to be within the string length\n\t\t\t * and discard ranges which are completely out of bonds.\n\t\t\t */\n\t\t\tranges = ranges.reduce<StringRange[]>((validRanges, range) => {\n\t\t\t\tif (range.start < this.text.length && range.end > 0) {\n\t\t\t\t\tvalidRanges.push({\n\t\t\t\t\t\tstart: (range.start < 0) ? 0 : range.start,\n\t\t\t\t\t\tend: (range.end > this.text.length) ? this.text.length : range.end,\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\treturn validRanges\n\t\t\t}, [])\n\n\t\t\t/**\n\t\t\t * Sort ranges ascendingly (necessary for next step)\n\t\t\t */\n\t\t\tranges.sort((a, b) => {\n\t\t\t\treturn a.start - b.start\n\t\t\t})\n\n\t\t\t/**\n\t\t\t * Merge overlapping or adjacent ranges\n\t\t\t */\n\t\t\tranges = ranges.reduce<StringRange[]>((mergedRanges, range) => {\n\t\t\t\t// If there are no ranges, just add the range\n\t\t\t\tif (!mergedRanges.length) {\n\t\t\t\t\tmergedRanges.push(range)\n\t\t\t\t} else {\n\t\t\t\t\t// If the range overlaps the last range, merge them\n\t\t\t\t\tconst idx = mergedRanges.length - 1\n\t\t\t\t\tif (mergedRanges[idx]!.end >= range.start) {\n\t\t\t\t\t\tmergedRanges[idx] = {\n\t\t\t\t\t\t\tstart: mergedRanges[idx]!.start,\n\t\t\t\t\t\t\tend: Math.max(mergedRanges[idx]!.end, range.end),\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmergedRanges.push(range)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn mergedRanges\n\t\t\t}, [])\n\n\t\t\treturn ranges\n\t\t},\n\n\t\t/**\n\t\t * Calculate the different chunks to show based on the ranges to highlight.\n\t\t */\n\t\tchunks(): HighlightChunk[] {\n\t\t\t// If the ranges array is empty, show only one chunk with all text\n\t\t\tif (this.ranges.length === 0) {\n\t\t\t\treturn [{\n\t\t\t\t\tstart: 0,\n\t\t\t\t\tend: this.text.length,\n\t\t\t\t\thighlight: false,\n\t\t\t\t\ttext: this.text,\n\t\t\t\t}]\n\t\t\t}\n\n\t\t\t// Calculate the chunks\n\t\t\tconst chunks: HighlightChunk[] = []\n\t\t\tlet currentIndex = 0\n\t\t\tlet currentRange = 0\n\t\t\t// Iterate over all characters in the text\n\t\t\twhile (currentIndex < this.text.length) {\n\t\t\t\t// Get the first range to highlight\n\t\t\t\tconst range = this.ranges[currentRange]!\n\t\t\t\t// If the range starts at the current index, construct a chunk to highlight,\n\t\t\t\t// set the next range and continue with the next iteration.\n\t\t\t\tif (range.start === currentIndex) {\n\t\t\t\t\tchunks.push({\n\t\t\t\t\t\t...range,\n\t\t\t\t\t\thighlight: true,\n\t\t\t\t\t\ttext: this.text.slice(range.start, range.end),\n\t\t\t\t\t})\n\t\t\t\t\tcurrentRange++\n\t\t\t\t\tcurrentIndex = range.end\n\t\t\t\t\t// If this was the last range to highlight and we haven't reached the end of the text,\n\t\t\t\t\t// add the rest of the text without highlighting.\n\t\t\t\t\tif (currentRange >= this.ranges.length && currentIndex < this.text.length) {\n\t\t\t\t\t\tchunks.push({\n\t\t\t\t\t\t\tstart: currentIndex,\n\t\t\t\t\t\t\tend: this.text.length,\n\t\t\t\t\t\t\thighlight: false,\n\t\t\t\t\t\t\ttext: this.text.slice(currentIndex),\n\t\t\t\t\t\t})\n\t\t\t\t\t\t// Set the current index so the while loop ends.\n\t\t\t\t\t\tcurrentIndex = this.text.length\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\t// If the current range does start after the current index, construct a chunk without\n\t\t\t\t// highlighting and set the current index to the start of the current range.\n\t\t\t\tchunks.push({\n\t\t\t\t\tstart: currentIndex,\n\t\t\t\t\tend: range.start,\n\t\t\t\t\thighlight: false,\n\t\t\t\t\ttext: this.text.slice(currentIndex, range.start),\n\t\t\t\t})\n\t\t\t\tcurrentIndex = range.start\n\t\t\t}\n\t\t\treturn chunks\n\t\t},\n\t},\n\n\t/**\n\t * The render function to display the component\n\t */\n\trender() {\n\t\tif (!this.ranges.length) {\n\t\t\treturn h('span', {}, this.text)\n\t\t}\n\n\t\treturn h('span', {}, this.chunks.map((chunk) => {\n\t\t\treturn chunk.highlight ? h('strong', {}, chunk.text) : chunk.text\n\t\t}))\n\t},\n})\n</script>\n"],"names":[],"mappings":"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"}