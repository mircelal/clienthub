import { getBaseUrl, getRootUrl } from "@nextcloud/router";
import { u } from "unist-builder";
import { visit, SKIP } from "unist-util-visit";
import { defineComponent, h } from "vue";
import { l as logger } from "./logger-D3RVzcfQ.mjs";
/*!
 * SPDX-FileCopyrightText: 2022 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
const URL_PATTERN = /(\s|^)(https?:\/\/)([-A-Z0-9+_.]+(?::[0-9]+)?(?:\/[-A-Z0-9+&@#%?=~_|!:,.;()]*)*)(\s|$)/ig;
const URL_PATTERN_AUTOLINK = /(\s|\(|^)((https?:\/\/)([-A-Z0-9+_.]+[-A-Z0-9]+(?::[0-9]+)?(?:\/[-A-Z0-9+&@#%?=~_|!:,.;()]*)*))(?=\s|\)|$)/ig;
const NcLink = defineComponent({
  name: "NcLink",
  props: {
    href: {
      type: String,
      required: true
    }
  },
  render() {
    return h("a", {
      href: this.href,
      rel: "noopener noreferrer",
      target: "_blank",
      class: "rich-text--external-link"
    }, [this.href.trim()]);
  }
});
function remarkAutolink({ autolink, useMarkdown, useExtendedMarkdown }) {
  return function(tree) {
    if (useExtendedMarkdown || !useMarkdown || !autolink) {
      return;
    }
    visit(tree, (node) => node.type === "text", (node, index, parent) => {
      let parsed = parseUrl(node.value);
      if (typeof parsed === "string") {
        parsed = [u("text", parsed)];
      } else {
        parsed = parsed.map((n) => {
          if (typeof n === "string") {
            return u("text", n);
          }
          return u("link", {
            url: n.props.href
          }, [u("text", n.props.href)]);
        }).filter((x) => x).flat();
      }
      parent.children.splice(index, 1, ...parsed);
      return [SKIP, (index ?? 0) + parsed.length];
    });
  };
}
function parseUrl(text) {
  let match = URL_PATTERN_AUTOLINK.exec(text);
  const list = [];
  let start = 0;
  while (match !== null) {
    let href = match[2];
    let textAfter;
    let textBefore = text.substring(start, match.index + match[1].length);
    if (href[0] === " ") {
      textBefore += href[0];
      href = href.substring(1).trim();
    }
    const lastChar = href[href.length - 1];
    if (lastChar === "." || lastChar === "," || lastChar === ";" || match[0][0] === "(" && lastChar === ")") {
      href = href.substring(0, href.length - 1);
      textAfter = lastChar;
    }
    list.push(textBefore);
    list.push({ component: NcLink, props: { href } });
    if (textAfter) {
      list.push(textAfter);
    }
    start = match.index + match[0].length;
    match = URL_PATTERN_AUTOLINK.exec(text);
  }
  list.push(text.substring(start));
  const joinedText = list.map((item) => typeof item === "string" ? item : item.props.href).join("");
  if (text === joinedText) {
    return list;
  }
  logger.error("[NcRichText] Failed to reassemble the chunked text: " + text);
  return text;
}
function getRoute(router, url) {
  const removePrefix = (str, prefix) => str.startsWith(prefix) ? str.slice(prefix.length) : str;
  const removePrefixes = (str, ...prefixes) => prefixes.reduce((acc, prefix) => removePrefix(acc, prefix), str);
  if (!router) {
    return null;
  }
  const isAbsoluteURL = /^https?:\/\//.test(url);
  const isNonHttpLink = /^[a-z][a-z0-9+.-]*:.+/.test(url);
  if (!isAbsoluteURL && isNonHttpLink) {
    return null;
  }
  if (isAbsoluteURL && !url.startsWith(getBaseUrl())) {
    return null;
  }
  if (!isAbsoluteURL && !url.startsWith("/")) {
    return null;
  }
  const relativeUrl = isAbsoluteURL ? removePrefixes(url, getBaseUrl(), "/index.php") : url;
  const relativeRouterBase = removePrefixes(router.options.history.base, getRootUrl(), "/index.php");
  const potentialRouterPath = removePrefixes(relativeUrl, relativeRouterBase) || "/";
  const route = router.resolve(potentialRouterPath);
  if (!route.matched.length) {
    return null;
  }
  return route.fullPath;
}
export {
  URL_PATTERN as U,
  getRoute as g,
  parseUrl as p,
  remarkAutolink as r
};
//# sourceMappingURL=autolink-U5pBzLgI.mjs.map
