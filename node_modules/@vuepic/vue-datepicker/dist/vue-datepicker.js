import { useAttrs as Jn, createElementBlock as W, openBlock as w, createElementVNode as he, unref as s, reactive as ea, computed as j, ref as Z, toRef as qt, watch as rt, defineComponent as We, onMounted as Ue, onUnmounted as Ut, renderSlot as ie, normalizeProps as ze, mergeProps as He, Fragment as ke, createCommentVNode as Q, normalizeStyle as lt, createTextVNode as gt, toDisplayString as Ke, onBeforeUpdate as Zn, nextTick as at, withModifiers as Xt, normalizeClass as De, withDirectives as ua, renderList as Ce, vShow as ia, createVNode as tt, createBlock as Te, withCtx as we, withKeys as xn, Transition as Vt, createSlots as Ge, useSlots as Yt, guardReactiveProps as Je, resolveDynamicComponent as fa, toValue as el, h as tl, render as nn, getCurrentScope as al, onScopeDispose as nl, getCurrentInstance as ll, isRef as ln, Teleport as rl } from "vue";
import { format as ft, isEqual as Nt, isValid as da, addMonths as Ct, subMonths as Jt, getMonth as Me, getYear as ye, set as Se, startOfMonth as ol, setMonth as sl, setYear as ut, isAfter as _t, isBefore as Ft, eachDayOfInterval as bn, getSeconds as zt, getMinutes as $t, getHours as yt, startOfWeek as Wa, endOfWeek as kn, setHours as ul, setMinutes as il, setSeconds as wn, setMilliseconds as Dn, parse as Na, isDate as dl, subDays as cl, addDays as kt, addHours as fl, addYears as Mn, subYears as $n, endOfYear as An, startOfYear as Gt, differenceInYears as vl, add as Tn, sub as ml, getWeek as pl, getISOWeek as gl, isSameQuarter as rn, eachQuarterOfInterval as yl, startOfQuarter as hl, endOfQuarter as on, getQuarter as sn, differenceInCalendarDays as bl, getDay as kl } from "date-fns";
function jt() {
  const e = Jn();
  return w(), W(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon",
      role: "img",
      ...e
    },
    [
      he("path", {
        d: "M29.333 8c0-2.208-1.792-4-4-4h-18.667c-2.208 0-4 1.792-4 4v18.667c0 2.208 1.792 4 4 4h18.667c2.208 0 4-1.792 4-4v-18.667zM26.667 8v18.667c0 0.736-0.597 1.333-1.333 1.333 0 0-18.667 0-18.667 0-0.736 0-1.333-0.597-1.333-1.333 0 0 0-18.667 0-18.667 0-0.736 0.597-1.333 1.333-1.333 0 0 18.667 0 18.667 0 0.736 0 1.333 0.597 1.333 1.333z"
      }),
      he("path", {
        d: "M20 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
      }),
      he("path", {
        d: "M9.333 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
      }),
      he("path", {
        d: "M4 14.667h24c0.736 0 1.333-0.597 1.333-1.333s-0.597-1.333-1.333-1.333h-24c-0.736 0-1.333 0.597-1.333 1.333s0.597 1.333 1.333 1.333z"
      })
    ]
  );
}
jt.compatConfig = {
  MODE: 3
};
function Sn() {
  return w(), W(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon",
      role: "img"
    },
    [
      he("path", {
        d: "M23.057 7.057l-16 16c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l16-16c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0z"
      }),
      he("path", {
        d: "M7.057 8.943l16 16c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885l-16-16c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z"
      })
    ]
  );
}
Sn.compatConfig = {
  MODE: 3
};
function Ua() {
  return w(), W(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon",
      role: "img"
    },
    [
      he("path", {
        d: "M20.943 23.057l-7.057-7.057c0 0 7.057-7.057 7.057-7.057 0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-8 8c-0.521 0.521-0.521 1.365 0 1.885l8 8c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z"
      })
    ]
  );
}
Ua.compatConfig = {
  MODE: 3
};
function Va() {
  return w(), W(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon",
      role: "img"
    },
    [
      he("path", {
        d: "M12.943 24.943l8-8c0.521-0.521 0.521-1.365 0-1.885l-8-8c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885l7.057 7.057c0 0-7.057 7.057-7.057 7.057-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0z"
      })
    ]
  );
}
Va.compatConfig = {
  MODE: 3
};
function ja() {
  return w(), W(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon",
      role: "img"
    },
    [
      he("path", {
        d: "M16 1.333c-8.095 0-14.667 6.572-14.667 14.667s6.572 14.667 14.667 14.667c8.095 0 14.667-6.572 14.667-14.667s-6.572-14.667-14.667-14.667zM16 4c6.623 0 12 5.377 12 12s-5.377 12-12 12c-6.623 0-12-5.377-12-12s5.377-12 12-12z"
      }),
      he("path", {
        d: "M14.667 8v8c0 0.505 0.285 0.967 0.737 1.193l5.333 2.667c0.658 0.329 1.46 0.062 1.789-0.596s0.062-1.46-0.596-1.789l-4.596-2.298c0 0 0-7.176 0-7.176 0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
      })
    ]
  );
}
ja.compatConfig = {
  MODE: 3
};
function Ka() {
  return w(), W(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon",
      role: "img"
    },
    [
      he("path", {
        d: "M24.943 19.057l-8-8c-0.521-0.521-1.365-0.521-1.885 0l-8 8c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l7.057-7.057c0 0 7.057 7.057 7.057 7.057 0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z"
      })
    ]
  );
}
Ka.compatConfig = {
  MODE: 3
};
function Ga() {
  return w(), W(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon",
      role: "img"
    },
    [
      he("path", {
        d: "M7.057 12.943l8 8c0.521 0.521 1.365 0.521 1.885 0l8-8c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-7.057 7.057c0 0-7.057-7.057-7.057-7.057-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z"
      })
    ]
  );
}
Ga.compatConfig = {
  MODE: 3
};
const Ze = (e, t) => t ? new Date(e.toLocaleString("en-US", { timeZone: t })) : new Date(e), Qa = (e, t, l) => {
  const n = La(e, t, l);
  return n || H();
}, wl = (e, t, l) => {
  const n = t.dateInTz ? Ze(new Date(e), t.dateInTz) : H(e);
  return l ? Fe(n, !0) : n;
}, La = (e, t, l) => {
  if (!e) return null;
  const n = l ? Fe(H(e), !0) : H(e);
  return t ? t.exactMatch ? wl(e, t, l) : Ze(n, t.timezone) : n;
}, Dl = (e) => {
  const l = new Date(e.getFullYear(), 0, 1).getTimezoneOffset();
  return e.getTimezoneOffset() < l;
}, Ml = (e, t) => {
  if (!e) return 0;
  const l = /* @__PURE__ */ new Date(), n = new Date(l.toLocaleString("en-US", { timeZone: "UTC" })), a = new Date(l.toLocaleString("en-US", { timeZone: e })), i = (Dl(t ?? a) ? a : t ?? a).getTimezoneOffset() / 60;
  return (+n - +a) / (1e3 * 60 * 60) - i;
};
var ot = /* @__PURE__ */ ((e) => (e.month = "month", e.year = "year", e))(ot || {}), st = /* @__PURE__ */ ((e) => (e.top = "top", e.bottom = "bottom", e))(st || {}), Ot = /* @__PURE__ */ ((e) => (e.header = "header", e.calendar = "calendar", e.timePicker = "timePicker", e))(Ot || {}), je = /* @__PURE__ */ ((e) => (e.month = "month", e.year = "year", e.calendar = "calendar", e.time = "time", e.minutes = "minutes", e.hours = "hours", e.seconds = "seconds", e))(je || {});
const $l = ["timestamp", "date", "iso"];
var Qe = /* @__PURE__ */ ((e) => (e.up = "up", e.down = "down", e.left = "left", e.right = "right", e))(Qe || {}), Re = /* @__PURE__ */ ((e) => (e.arrowUp = "ArrowUp", e.arrowDown = "ArrowDown", e.arrowLeft = "ArrowLeft", e.arrowRight = "ArrowRight", e.enter = "Enter", e.space = " ", e.esc = "Escape", e.tab = "Tab", e.home = "Home", e.end = "End", e.pageUp = "PageUp", e.pageDown = "PageDown", e))(Re || {}), Lt = /* @__PURE__ */ ((e) => (e.MONTH_AND_YEAR = "MM-yyyy", e.YEAR = "yyyy", e.DATE = "dd-MM-yyyy", e))(Lt || {});
function un(e) {
  return (t) => {
    const l = new Intl.DateTimeFormat(e, {
      weekday: "short",
      timeZone: "UTC"
    }).format(/* @__PURE__ */ new Date(`2017-01-0${t}T00:00:00+00:00`));
    return e === "ar" ? l.slice(2, 5) : l.slice(0, 2);
  };
}
function Al(e) {
  return (t) => ft(Ze(/* @__PURE__ */ new Date(`2017-01-0${t}T00:00:00+00:00`), "UTC"), "EEEEEE", { locale: e });
}
const Tl = (e, t, l) => {
  const n = [1, 2, 3, 4, 5, 6, 7];
  let a;
  if (e !== null)
    try {
      a = n.map(Al(e));
    } catch {
      a = n.map(un(t));
    }
  else
    a = n.map(un(t));
  const f = a.slice(0, l), i = a.slice(l + 1, a.length);
  return [a[l]].concat(...i).concat(...f);
}, qa = (e, t, l) => {
  const n = [];
  for (let a = +e[0]; a <= +e[1]; a++)
    n.push({ value: +a, text: Ja(a, t) });
  return l ? n.reverse() : n;
}, Pn = (e, t, l) => {
  const n = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].map((f) => {
    const i = f < 10 ? `0${f}` : f;
    return /* @__PURE__ */ new Date(`2017-${i}-01T00:00:00+00:00`);
  });
  if (e !== null)
    try {
      const f = l === "long" ? "LLLL" : "LLL";
      return n.map((i, g) => {
        const d = ft(Ze(i, "UTC"), f, { locale: e });
        return {
          text: d.charAt(0).toUpperCase() + d.substring(1),
          value: g
        };
      });
    } catch {
    }
  const a = new Intl.DateTimeFormat(t, { month: l, timeZone: "UTC" });
  return n.map((f, i) => {
    const g = a.format(f);
    return {
      text: g.charAt(0).toUpperCase() + g.substring(1),
      value: i
    };
  });
}, Sl = (e) => [12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11][e], Le = (e) => {
  const t = s(e);
  return t?.$el ? t?.$el : t;
}, Pl = (e) => ({ type: "dot", ...e ?? {} }), Rn = (e) => Array.isArray(e) ? !!e[0] && !!e[1] : !1, Xa = {
  prop: (e) => `"${e}" prop must be enabled!`,
  dateArr: (e) => `You need to use array as "model-value" binding in order to support "${e}"`
}, Ne = (e) => e, dn = (e) => e === 0 ? e : !e || isNaN(+e) ? null : +e, cn = (e) => e === null, Cn = (e) => {
  if (e)
    return [...e.querySelectorAll("input, button, select, textarea, a[href]")][0];
}, Rl = (e) => {
  const t = [], l = (n) => n.filter((a) => a);
  for (let n = 0; n < e.length; n += 3) {
    const a = [e[n], e[n + 1], e[n + 2]];
    t.push(l(a));
  }
  return t;
}, Zt = (e, t, l) => {
  const n = l != null, a = t != null;
  if (!n && !a) return !1;
  const f = +l, i = +t;
  return n && a ? +e > f || +e < i : n ? +e > f : a ? +e < i : !1;
}, Ht = (e, t) => Rl(e).map((l) => l.map((n) => {
  const { active: a, disabled: f, isBetween: i, highlighted: g } = t(n);
  return {
    ...n,
    active: a,
    disabled: f,
    className: {
      dp__overlay_cell_active: a,
      dp__overlay_cell: !a,
      dp__overlay_cell_disabled: f,
      dp__overlay_cell_pad: !0,
      dp__overlay_cell_active_disabled: f && a,
      dp__cell_in_between: i,
      "dp--highlighted": g
    }
  };
})), Dt = (e, t, l = !1) => {
  e && t.allowStopPropagation && (l && e.stopImmediatePropagation(), e.stopPropagation());
}, Cl = () => [
  "a[href]",
  "area[href]",
  "input:not([disabled]):not([type='hidden'])",
  "select:not([disabled])",
  "textarea:not([disabled])",
  "button:not([disabled])",
  "[tabindex]:not([tabindex='-1'])",
  "[data-datepicker-instance]"
].join(", ");
function Ol(e, t) {
  let l = [...document.querySelectorAll(Cl())];
  l = l.filter((a) => !e.contains(a) || a.hasAttribute("data-datepicker-instance"));
  const n = l.indexOf(e);
  if (n >= 0 && (t ? n - 1 >= 0 : n + 1 <= l.length))
    return l[n + (t ? -1 : 1)];
}
const Fa = (e, t) => e?.querySelector(`[data-dp-element="${t}"]`), Ja = (e, t) => new Intl.NumberFormat(t, { useGrouping: !1, style: "decimal" }).format(e), Za = (e, t) => ft(e, t ?? Lt.DATE), Ta = (e) => Array.isArray(e), ca = (e, t, l) => t.get(Za(e, l)), Bl = (e, t) => e ? t ? t instanceof Map ? !!ca(e, t) : t(H(e)) : !1 : !0, qe = (e, t, l = !1, n) => {
  if (e.key === Re.enter || e.key === Re.space)
    return l && e.preventDefault(), t();
  if (n) return n(e);
}, _l = () => "ontouchstart" in window || navigator.maxTouchPoints > 0, On = (e, t) => e ? Lt.MONTH_AND_YEAR : t ? Lt.YEAR : Lt.DATE, Bn = (e) => e < 10 ? `0${e}` : e, fn = (e, t, l, n, a, f) => {
  const i = Na(e, t.slice(0, e.length), /* @__PURE__ */ new Date(), { locale: f });
  return da(i) && dl(i) ? n || a ? i : Se(i, {
    hours: +l.hours,
    minutes: +l?.minutes,
    seconds: +l?.seconds,
    milliseconds: 0
  }) : null;
}, Yl = (e, t, l, n, a, f) => {
  const i = Array.isArray(l) ? l[0] : l;
  if (typeof t == "string")
    return fn(e, t, i, n, a, f);
  if (Array.isArray(t)) {
    let g = null;
    for (const d of t)
      if (g = fn(e, d, i, n, a, f), g)
        break;
    return g;
  }
  return typeof t == "function" ? t(e) : null;
}, H = (e) => e ? new Date(e) : /* @__PURE__ */ new Date(), Il = (e, t, l) => {
  if (t) {
    const a = (e.getMonth() + 1).toString().padStart(2, "0"), f = e.getDate().toString().padStart(2, "0"), i = e.getHours().toString().padStart(2, "0"), g = e.getMinutes().toString().padStart(2, "0"), d = l ? e.getSeconds().toString().padStart(2, "0") : "00";
    return `${e.getFullYear()}-${a}-${f}T${i}:${g}:${d}.000Z`;
  }
  const n = Date.UTC(
    e.getUTCFullYear(),
    e.getUTCMonth(),
    e.getUTCDate(),
    e.getUTCHours(),
    e.getUTCMinutes(),
    e.getUTCSeconds()
  );
  return new Date(n).toISOString();
}, Fe = (e, t) => {
  const l = H(JSON.parse(JSON.stringify(e))), n = Se(l, { hours: 0, minutes: 0, seconds: 0, milliseconds: 0 });
  return t ? ol(n) : n;
}, Mt = (e, t, l, n) => {
  let a = e ? H(e) : H();
  return (t || t === 0) && (a = ul(a, +t)), (l || l === 0) && (a = il(a, +l)), (n || n === 0) && (a = wn(a, +n)), Dn(a, 0);
}, Be = (e, t) => !e || !t ? !1 : Ft(Fe(e), Fe(t)), $e = (e, t) => !e || !t ? !1 : Nt(Fe(e), Fe(t)), Ee = (e, t) => !e || !t ? !1 : _t(Fe(e), Fe(t)), xt = (e, t, l) => e?.[0] && e?.[1] ? Ee(l, e[0]) && Be(l, e[1]) : e?.[0] && t ? Ee(l, e[0]) && Be(l, t) || Be(l, e[0]) && Ee(l, t) : !1, it = (e) => {
  const t = Se(new Date(e), { date: 1 });
  return Fe(t);
}, Sa = (e, t, l) => t && (l || l === 0) ? Object.fromEntries(
  ["hours", "minutes", "seconds"].map((n) => n === t ? [n, l] : [n, isNaN(+e[n]) ? void 0 : +e[n]])
) : {
  hours: isNaN(+e.hours) ? void 0 : +e.hours,
  minutes: isNaN(+e.minutes) ? void 0 : +e.minutes,
  seconds: isNaN(+e.seconds) ? void 0 : +e.seconds
}, Bt = (e) => ({
  hours: yt(e),
  minutes: $t(e),
  seconds: zt(e)
}), _n = (e, t) => {
  if (t) {
    const l = ye(H(t));
    if (l > e) return 12;
    if (l === e) return Me(H(t));
  }
}, Yn = (e, t) => {
  if (t) {
    const l = ye(H(t));
    return l < e ? -1 : l === e ? Me(H(t)) : void 0;
  }
}, Wt = (e) => {
  if (e) return ye(H(e));
}, In = (e, t) => {
  const l = Ee(e, t) ? t : e, n = Ee(t, e) ? t : e;
  return bn({ start: l, end: n });
}, El = (e) => {
  const t = Ct(e, 1);
  return { month: Me(t), year: ye(t) };
}, mt = (e, t) => {
  const l = Wa(e, { weekStartsOn: +t }), n = kn(e, { weekStartsOn: +t });
  return [l, n];
}, En = (e, t) => {
  const l = {
    hours: yt(H()),
    minutes: $t(H()),
    seconds: t ? zt(H()) : 0
  };
  return Object.assign(l, e);
}, wt = (e, t, l) => [Se(H(e), { date: 1 }), Se(H(), { month: t, year: l, date: 1 })], pt = (e, t, l) => {
  let n = e ? H(e) : H();
  return (t || t === 0) && (n = sl(n, t)), l && (n = ut(n, l)), n;
}, Nn = (e, t, l, n, a) => {
  if (!n || a && !t || !a && !l) return !1;
  const f = a ? Ct(e, 1) : Jt(e, 1), i = [Me(f), ye(f)];
  return a ? !Ll(...i, t) : !Nl(...i, l);
}, Nl = (e, t, l) => Be(...wt(l, e, t)) || $e(...wt(l, e, t)), Ll = (e, t, l) => Ee(...wt(l, e, t)) || $e(...wt(l, e, t)), Ln = (e, t, l, n, a, f, i) => {
  if (typeof t == "function" && !i) return t(e);
  const g = l ? { locale: l } : void 0;
  return Array.isArray(e) ? `${ft(e[0], f, g)}${a && !e[1] ? "" : n}${e[1] ? ft(e[1], f, g) : ""}` : ft(e, f, g);
}, It = (e) => {
  if (e) return null;
  throw new Error(Xa.prop("partial-range"));
}, oa = (e, t) => {
  if (t) return e();
  throw new Error(Xa.prop("range"));
}, za = (e) => Array.isArray(e) ? da(e[0]) && (e[1] ? da(e[1]) : !0) : e ? da(e) : !1, Fl = (e, t) => Se(t ?? H(), {
  hours: +e.hours || 0,
  minutes: +e.minutes || 0,
  seconds: +e.seconds || 0
}), Pa = (e, t, l, n) => {
  if (!e) return !0;
  if (n) {
    const a = l === "max" ? Ft(e, t) : _t(e, t), f = { seconds: 0, milliseconds: 0 };
    return a || Nt(Se(e, f), Se(t, f));
  }
  return l === "max" ? e.getTime() <= t.getTime() : e.getTime() >= t.getTime();
}, Ra = (e, t, l) => e ? Fl(e, t) : H(l ?? t), vn = (e, t, l, n, a) => {
  if (Array.isArray(n)) {
    const i = Ra(e, n[0], t), g = Ra(e, n[1], t);
    return Pa(n[0], i, l, !!t) && Pa(n[1], g, l, !!t) && a;
  }
  const f = Ra(e, n, t);
  return Pa(n, f, l, !!t) && a;
}, Ca = (e) => Se(H(), Bt(e)), zl = (e, t, l) => {
  if (e instanceof Map) {
    const n = `${Bn(l + 1)}-${t}`;
    return e.size ? e.has(n) : !1;
  }
  return typeof e == "function" ? e(Fe(Se(H(), { month: l, year: t }), !0)) : !1;
}, Hl = (e, t, l) => {
  if (e instanceof Map) {
    const n = `${Bn(l + 1)}-${t}`;
    return e.size ? e.has(n) : !0;
  }
  return !0;
}, Fn = (e, t, l) => typeof e == "function" ? e({ month: t, year: l }) : !!e.months.find((n) => n.month === t && n.year === l), xa = (e, t) => typeof e == "function" ? e(t) : e.years.includes(t), Ha = (e) => `dp-${ft(e, "yyyy-MM-dd")}`, mn = (e, t) => {
  const l = cl(Fe(t), e), n = kt(Fe(t), e);
  return { before: l, after: n };
}, zn = (e, t) => t < +e[0] || t > +e[1], Kt = ea({
  menuFocused: !1,
  shiftKeyInMenu: !1
}), Hn = () => {
  const e = (n) => {
    Kt.menuFocused = n;
  }, t = (n) => {
    Kt.shiftKeyInMenu !== n && (Kt.shiftKeyInMenu = n);
  };
  return {
    control: j(() => ({ shiftKeyInMenu: Kt.shiftKeyInMenu, menuFocused: Kt.menuFocused })),
    setMenuFocused: e,
    setShiftKey: t
  };
}, Pe = ea({
  monthYear: [],
  calendar: [],
  time: [],
  actionRow: [],
  selectionGrid: [],
  timePicker: {
    0: [],
    1: []
  },
  monthPicker: []
}), Oa = Z(null), sa = Z(!1), Ba = Z(!1), _a = Z(!1), Ya = Z(!1), Ve = Z(0), Ie = Z(0), At = () => {
  const e = j(() => sa.value ? [...Pe.selectionGrid, Pe.actionRow].filter((M) => M.length) : Ba.value ? [
    ...Pe.timePicker[0],
    ...Pe.timePicker[1],
    Ya.value ? [] : [Oa.value],
    Pe.actionRow
  ].filter((M) => M.length) : _a.value ? [...Pe.monthPicker, Pe.actionRow] : [Pe.monthYear, ...Pe.calendar, Pe.time, Pe.actionRow].filter((M) => M.length)), t = (M) => {
    Ve.value = M ? Ve.value + 1 : Ve.value - 1;
    let A = null;
    e.value[Ie.value] && (A = e.value[Ie.value][Ve.value]), !A && e.value[Ie.value + (M ? 1 : -1)] ? (Ie.value = Ie.value + (M ? 1 : -1), Ve.value = M ? 0 : e.value[Ie.value].length - 1) : A || (Ve.value = M ? Ve.value - 1 : Ve.value + 1);
  }, l = (M) => {
    if (Ie.value === 0 && !M || Ie.value === e.value.length && M) return;
    Ie.value = M ? Ie.value + 1 : Ie.value - 1, e.value[Ie.value] ? e.value[Ie.value] && !e.value[Ie.value][Ve.value] && Ve.value !== 0 && (Ve.value = e.value[Ie.value].length - 1) : Ie.value = M ? Ie.value - 1 : Ie.value + 1;
  }, n = (M) => {
    let A = null;
    e.value[Ie.value] && (A = e.value[Ie.value][Ve.value]), A ? A.focus({ preventScroll: !sa.value }) : Ve.value = M ? Ve.value - 1 : Ve.value + 1;
  }, a = () => {
    t(!0), n(!0);
  }, f = () => {
    t(!1), n(!1);
  }, i = () => {
    l(!1), n(!0);
  }, g = () => {
    l(!0), n(!0);
  }, d = (M, A) => {
    Pe[A] = M;
  }, P = (M, A) => {
    Pe[A] = M;
  }, v = () => {
    Ve.value = 0, Ie.value = 0;
  };
  return {
    buildMatrix: d,
    buildMultiLevelMatrix: P,
    setTimePickerBackRef: (M) => {
      Oa.value = M;
    },
    setSelectionGrid: (M) => {
      sa.value = M, v(), M || (Pe.selectionGrid = []);
    },
    setTimePicker: (M, A = !1) => {
      Ba.value = M, Ya.value = A, v(), M || (Pe.timePicker[0] = [], Pe.timePicker[1] = []);
    },
    setTimePickerElements: (M, A = 0) => {
      Pe.timePicker[A] = M;
    },
    arrowRight: a,
    arrowLeft: f,
    arrowUp: i,
    arrowDown: g,
    clearArrowNav: () => {
      Pe.monthYear = [], Pe.calendar = [], Pe.time = [], Pe.actionRow = [], Pe.selectionGrid = [], Pe.timePicker[0] = [], Pe.timePicker[1] = [], sa.value = !1, Ba.value = !1, Ya.value = !1, _a.value = !1, v(), Oa.value = null;
    },
    setMonthPicker: (M) => {
      _a.value = M, v();
    },
    refSets: Pe
    // exposed for testing
  };
}, pn = (e) => ({
  menuAppearTop: "dp-menu-appear-top",
  menuAppearBottom: "dp-menu-appear-bottom",
  open: "dp-slide-down",
  close: "dp-slide-up",
  next: "calendar-next",
  previous: "calendar-prev",
  vNext: "dp-slide-up",
  vPrevious: "dp-slide-down",
  ...e ?? {}
}), Wl = (e) => ({
  toggleOverlay: "Toggle overlay",
  menu: "Datepicker menu",
  input: "Datepicker input",
  openTimePicker: "Open time picker",
  closeTimePicker: "Close time Picker",
  incrementValue: (t) => `Increment ${t}`,
  decrementValue: (t) => `Decrement ${t}`,
  openTpOverlay: (t) => `Open ${t} overlay`,
  amPmButton: "Switch AM/PM mode",
  openYearsOverlay: "Open years overlay",
  openMonthsOverlay: "Open months overlay",
  nextMonth: "Next month",
  prevMonth: "Previous month",
  nextYear: "Next year",
  prevYear: "Previous year",
  day: void 0,
  weekDay: void 0,
  clearInput: "Clear value",
  calendarIcon: "Calendar icon",
  timePicker: "Time picker",
  monthPicker: (t) => `Month picker${t ? " overlay" : ""}`,
  yearPicker: (t) => `Year picker${t ? " overlay" : ""}`,
  timeOverlay: (t) => `${t} overlay`,
  ...e ?? {}
}), gn = (e) => e ? typeof e == "boolean" ? e ? 2 : 0 : +e >= 2 ? +e : 2 : 0, Ul = (e) => {
  const t = typeof e == "object" && e, l = {
    static: !0,
    solo: !1
  };
  if (!e) return { ...l, count: gn(!1) };
  const n = t ? e : {}, a = t ? n.count ?? !0 : e, f = gn(a);
  return Object.assign(l, n, { count: f });
}, Vl = (e, t, l) => e || (typeof l == "string" ? l : t), jl = (e) => typeof e == "boolean" ? e ? pn({}) : !1 : pn(e), Kl = (e) => {
  const t = {
    enterSubmit: !0,
    tabSubmit: !0,
    openMenu: "open",
    selectOnFocus: !1,
    rangeSeparator: " - ",
    escClose: !0
  };
  return typeof e == "object" ? { ...t, ...e ?? {}, enabled: !0 } : { ...t, enabled: e };
}, Gl = (e) => ({
  months: [],
  years: [],
  times: { hours: [], minutes: [], seconds: [] },
  ...e ?? {}
}), Ql = (e) => ({
  showSelect: !0,
  showCancel: !0,
  showNow: !1,
  showPreview: !0,
  ...e ?? {}
}), ql = (e) => {
  const t = { input: !1 };
  return typeof e == "object" ? { ...t, ...e ?? {}, enabled: !0 } : {
    enabled: e,
    ...t
  };
}, Xl = (e) => ({ ...{
  allowStopPropagation: !0,
  closeOnScroll: !1,
  modeHeight: 255,
  allowPreventDefault: !1,
  closeOnClearValue: !0,
  closeOnAutoApply: !0,
  noSwipe: !1,
  keepActionRow: !1,
  onClickOutside: void 0,
  tabOutClosesMenu: !0,
  arrowLeft: void 0,
  keepViewOnOffsetClick: !1,
  timeArrowHoldThreshold: 0,
  shadowDom: !1,
  mobileBreakpoint: 600,
  setDateOnMenuClose: !1
}, ...e ?? {} }), Jl = (e) => {
  const t = {
    dates: Array.isArray(e) ? e.map((l) => H(l)) : [],
    years: [],
    months: [],
    quarters: [],
    weeks: [],
    weekdays: [],
    options: { highlightDisabled: !1 }
  };
  return typeof e == "function" ? e : { ...t, ...e ?? {} };
}, Zl = (e) => typeof e == "object" ? {
  type: e?.type ?? "local",
  hideOnOffsetDates: e?.hideOnOffsetDates ?? !1
} : {
  type: e,
  hideOnOffsetDates: !1
}, xl = (e) => {
  const t = {
    noDisabledRange: !1,
    showLastInRange: !0,
    minMaxRawRange: !1,
    partialRange: !0,
    disableTimeRangeValidation: !1,
    maxRange: void 0,
    minRange: void 0,
    autoRange: void 0,
    fixedStart: !1,
    fixedEnd: !1
  };
  return typeof e == "object" ? { enabled: !0, ...t, ...e } : {
    enabled: e,
    ...t
  };
}, er = (e) => e ? typeof e == "string" ? {
  timezone: e,
  exactMatch: !1,
  dateInTz: void 0,
  emitTimezone: void 0,
  convertModel: !0
} : {
  timezone: e.timezone,
  exactMatch: e.exactMatch ?? !1,
  dateInTz: e.dateInTz ?? void 0,
  emitTimezone: e.emitTimezone ?? void 0,
  convertModel: e.convertModel ?? !0
} : { timezone: void 0, exactMatch: !1, emitTimezone: void 0 }, Ia = (e, t, l, n) => new Map(
  e.map((a) => {
    const f = Qa(a, t, n);
    return [Za(f, l), f];
  })
), tr = (e, t) => e.length ? new Map(
  e.map((l) => {
    const n = Qa(l.date, t);
    return [Za(n, Lt.DATE), l];
  })
) : null, ar = (e) => {
  const t = On(e.isMonthPicker, e.isYearPicker);
  return {
    minDate: La(e.minDate, e.timezone, e.isSpecific),
    maxDate: La(e.maxDate, e.timezone, e.isSpecific),
    disabledDates: Ta(e.disabledDates) ? Ia(e.disabledDates, e.timezone, t, e.isSpecific) : e.disabledDates,
    allowedDates: Ta(e.allowedDates) ? Ia(e.allowedDates, e.timezone, t, e.isSpecific) : null,
    highlight: typeof e.highlight == "object" && Ta(e.highlight?.dates) ? Ia(e.highlight.dates, e.timezone, t) : e.highlight,
    markers: tr(e.markers, e.timezone)
  };
}, nr = (e) => typeof e == "boolean" ? { enabled: e, dragSelect: !0, limit: null } : {
  enabled: !!e,
  limit: e.limit ? +e.limit : null,
  dragSelect: e.dragSelect ?? !0
}, lr = (e) => ({
  ...Object.fromEntries(
    Object.keys(e).map((l) => {
      const n = l, a = e[n], f = typeof e[n] == "string" ? { [a]: !0 } : Object.fromEntries(a.map((i) => [i, !0]));
      return [l, f];
    })
  )
}), Oe = (e) => {
  const t = () => {
    const U = e.enableSeconds ? ":ss" : "", $ = e.enableMinutes ? ":mm" : "";
    return e.is24 ? `HH${$}${U}` : `hh${$}${U} aa`;
  }, l = () => e.format ? e.format : e.monthPicker ? "MM/yyyy" : e.timePicker ? t() : e.weekPicker ? `${C.value?.type === "iso" ? "II" : "ww"}-RR` : e.yearPicker ? "yyyy" : e.quarterPicker ? "QQQ/yyyy" : e.enableTimePicker ? `MM/dd/yyyy, ${t()}` : "MM/dd/yyyy", n = (U) => En(U, e.enableSeconds), a = () => z.value.enabled ? e.startTime && Array.isArray(e.startTime) ? [n(e.startTime[0]), n(e.startTime[1])] : null : e.startTime && !Array.isArray(e.startTime) ? n(e.startTime) : null, f = j(() => Ul(e.multiCalendars)), i = j(() => a()), g = j(() => Wl(e.ariaLabels)), d = j(() => Gl(e.filters)), P = j(() => jl(e.transitions)), v = j(() => Ql(e.actionRow)), R = j(
    () => Vl(e.previewFormat, e.format, l())
  ), h = j(() => Kl(e.textInput)), T = j(() => ql(e.inline)), F = j(() => Xl(e.config)), _ = j(() => Jl(e.highlight)), C = j(() => Zl(e.weekNumbers)), M = j(() => er(e.timezone)), A = j(() => nr(e.multiDates)), m = j(
    () => ar({
      minDate: e.minDate,
      maxDate: e.maxDate,
      disabledDates: e.disabledDates,
      allowedDates: e.allowedDates,
      highlight: _.value,
      markers: e.markers,
      timezone: M.value,
      isSpecific: e.monthPicker || e.yearPicker || e.quarterPicker,
      isMonthPicker: e.monthPicker,
      isYearPicker: e.yearPicker
    })
  ), z = j(() => xl(e.range)), L = j(() => lr(e.ui));
  return {
    defaultedTransitions: P,
    defaultedMultiCalendars: f,
    defaultedStartTime: i,
    defaultedAriaLabels: g,
    defaultedFilters: d,
    defaultedActionRow: v,
    defaultedPreviewFormat: R,
    defaultedTextInput: h,
    defaultedInline: T,
    defaultedConfig: F,
    defaultedHighlight: _,
    defaultedWeekNumbers: C,
    defaultedRange: z,
    propDates: m,
    defaultedTz: M,
    defaultedMultiDates: A,
    defaultedUI: L,
    getDefaultPattern: l,
    getDefaultStartTime: a,
    handleEventPropagation: (U) => {
      F.value.allowStopPropagation && U.stopPropagation(), F.value.allowPreventDefault && U.preventDefault();
    }
  };
}, rr = (e, t, { isInputFocused: l, isTextInputDate: n }) => {
  const a = Z(), { defaultedTextInput: f, defaultedRange: i, defaultedTz: g, defaultedMultiDates: d, getDefaultPattern: P } = Oe(t), v = Z(""), R = qt(t, "format"), h = qt(t, "formatLocale");
  rt(
    a,
    () => {
      typeof t.onInternalModelChange == "function" && e("internal-model-change", a.value, x(!0));
    },
    { deep: !0 }
  ), rt(i, (o, X) => {
    o.enabled !== X.enabled && (a.value = null);
  }), rt(R, () => {
    S();
  });
  const T = (o) => g.value.timezone && g.value.convertModel ? Ze(o, g.value.timezone) : o, F = (o) => {
    if (g.value.timezone && g.value.convertModel) {
      const X = Ml(g.value.timezone, o);
      return fl(o, X);
    }
    return o;
  }, _ = (o, X, B = !1) => Ln(
    o,
    t.format,
    t.formatLocale,
    f.value.rangeSeparator,
    t.modelAuto,
    X ?? P(),
    B
  ), C = (o) => o ? t.modelType ? k(o) : {
    hours: yt(o),
    minutes: $t(o),
    seconds: t.enableSeconds ? zt(o) : 0
  } : null, M = (o) => t.modelType ? k(o) : { month: Me(o), year: ye(o) }, A = (o) => Array.isArray(o) ? d.value.enabled ? o.map((X) => m(X, ut(H(), X))) : oa(
    () => [
      ut(H(), o[0]),
      o[1] ? ut(H(), o[1]) : It(i.value.partialRange)
    ],
    i.value.enabled
  ) : ut(H(), +o), m = (o, X) => (typeof o == "string" || typeof o == "number") && t.modelType ? q(o) : X, z = (o) => Array.isArray(o) ? [
    m(
      o[0],
      Mt(null, +o[0].hours, +o[0].minutes, o[0].seconds)
    ),
    m(
      o[1],
      Mt(null, +o[1].hours, +o[1].minutes, o[1].seconds)
    )
  ] : m(o, Mt(null, o.hours, o.minutes, o.seconds)), L = (o) => {
    const X = Se(H(), { date: 1 });
    return Array.isArray(o) ? d.value.enabled ? o.map((B) => m(B, pt(X, +B.month, +B.year))) : oa(
      () => [
        m(o[0], pt(X, +o[0].month, +o[0].year)),
        m(
          o[1],
          o[1] ? pt(X, +o[1].month, +o[1].year) : It(i.value.partialRange)
        )
      ],
      i.value.enabled
    ) : m(o, pt(X, +o.month, +o.year));
  }, le = (o) => {
    if (Array.isArray(o))
      return o.map((X) => q(X));
    throw new Error(Xa.dateArr("multi-dates"));
  }, U = (o) => {
    if (Array.isArray(o) && i.value.enabled) {
      const X = o[0], B = o[1];
      return [
        H(Array.isArray(X) ? X[0] : null),
        Array.isArray(B) && B.length ? H(B[0]) : null
      ];
    }
    return H(o[0]);
  }, $ = (o) => t.modelAuto ? Array.isArray(o) ? [q(o[0]), q(o[1])] : t.autoApply ? [q(o)] : [q(o), null] : Array.isArray(o) ? oa(
    () => o[1] ? [
      q(o[0]),
      o[1] ? q(o[1]) : It(i.value.partialRange)
    ] : [q(o[0])],
    i.value.enabled
  ) : q(o), ee = () => {
    Array.isArray(a.value) && i.value.enabled && a.value.length === 1 && a.value.push(It(i.value.partialRange));
  }, O = () => {
    const o = a.value;
    return [
      k(o[0]),
      o[1] ? k(o[1]) : It(i.value.partialRange)
    ];
  }, J = () => Array.isArray(a.value) ? a.value[1] ? O() : k(Ne(a.value[0])) : [], ce = () => (a.value || []).map((o) => k(o)), pe = (o = !1) => (o || ee(), t.modelAuto ? J() : d.value.enabled ? ce() : Array.isArray(a.value) ? oa(() => O(), i.value.enabled) : k(Ne(a.value))), p = (o) => !o || Array.isArray(o) && !o.length ? null : t.timePicker ? z(Ne(o)) : t.monthPicker ? L(Ne(o)) : t.yearPicker ? A(Ne(o)) : d.value.enabled ? le(Ne(o)) : t.weekPicker ? U(Ne(o)) : $(Ne(o)), Y = (o) => {
    if (n.value) return;
    const X = p(o);
    za(Ne(X)) ? (a.value = Ne(X), S()) : (a.value = null, v.value = "");
  }, te = () => {
    const o = (X) => ft(X, f.value.format);
    return `${o(a.value[0])} ${f.value.rangeSeparator} ${a.value[1] ? o(a.value[1]) : ""}`;
  }, y = () => l.value && a.value ? Array.isArray(a.value) ? te() : ft(a.value, f.value.format) : _(a.value), V = () => a.value ? d.value.enabled ? a.value.map((o) => _(o)).join("; ") : f.value.enabled && typeof f.value.format == "string" ? y() : _(a.value) : "", S = () => {
    !t.format || typeof t.format == "string" || f.value.enabled && typeof f.value.format == "string" ? v.value = V() : v.value = t.format(a.value);
  }, q = (o) => {
    if (t.utc) {
      const X = new Date(o);
      return t.utc === "preserve" ? new Date(X.getTime() + X.getTimezoneOffset() * 6e4) : X;
    }
    return t.modelType ? $l.includes(t.modelType) ? T(new Date(o)) : t.modelType === "format" && (typeof t.format == "string" || !t.format) ? T(
      Na(o, P(), /* @__PURE__ */ new Date(), { locale: h.value })
    ) : T(
      Na(o, t.modelType, /* @__PURE__ */ new Date(), { locale: h.value })
    ) : T(new Date(o));
  }, k = (o) => o ? t.utc ? Il(o, t.utc === "preserve", t.enableSeconds) : t.modelType ? t.modelType === "timestamp" ? +F(o) : t.modelType === "iso" ? F(o).toISOString() : t.modelType === "format" && (typeof t.format == "string" || !t.format) ? _(F(o)) : _(F(o), t.modelType, !0) : F(o) : "", se = (o, X = !1, B = !1) => {
    if (B) return o;
    if (e("update:model-value", o), g.value.emitTimezone && X) {
      const be = Array.isArray(o) ? o.map((Ae) => Ze(Ne(Ae), g.value.emitTimezone)) : Ze(Ne(o), g.value.emitTimezone);
      e("update:model-timezone-value", be);
    }
  }, u = (o) => Array.isArray(a.value) ? d.value.enabled ? a.value.map((X) => o(X)) : [
    o(a.value[0]),
    a.value[1] ? o(a.value[1]) : It(i.value.partialRange)
  ] : o(Ne(a.value)), re = () => {
    if (Array.isArray(a.value)) {
      const o = mt(a.value[0], t.weekStart), X = a.value[1] ? mt(a.value[1], t.weekStart) : [];
      return [o.map((B) => H(B)), X.map((B) => H(B))];
    }
    return mt(a.value, t.weekStart).map((o) => H(o));
  }, G = (o, X) => se(Ne(u(o)), !1, X), I = (o) => {
    const X = re();
    return o ? X : e("update:model-value", re());
  }, x = (o = !1) => (o || S(), t.monthPicker ? G(M, o) : t.timePicker ? G(C, o) : t.yearPicker ? G(ye, o) : t.weekPicker ? I(o) : se(pe(o), !0, o));
  return {
    inputValue: v,
    internalModelValue: a,
    checkBeforeEmit: () => a.value ? i.value.enabled ? i.value.partialRange ? a.value.length >= 1 : a.value.length === 2 : !!a.value : !1,
    parseExternalModelValue: Y,
    formatInputValue: S,
    emitModelValue: x
  };
}, or = (e, t) => {
  const { defaultedFilters: l, propDates: n } = Oe(e), { validateMonthYearInRange: a } = Tt(e), f = (v, R) => {
    let h = v;
    return l.value.months.includes(Me(h)) ? (h = R ? Ct(v, 1) : Jt(v, 1), f(h, R)) : h;
  }, i = (v, R) => {
    let h = v;
    return l.value.years.includes(ye(h)) ? (h = R ? Mn(v, 1) : $n(v, 1), i(h, R)) : h;
  }, g = (v, R = !1) => {
    const h = Se(H(), { month: e.month, year: e.year });
    let T = v ? Ct(h, 1) : Jt(h, 1);
    e.disableYearSelect && (T = ut(T, e.year));
    let F = Me(T), _ = ye(T);
    l.value.months.includes(F) && (T = f(T, v), F = Me(T), _ = ye(T)), l.value.years.includes(_) && (T = i(T, v), _ = ye(T)), a(F, _, v, e.preventMinMaxNavigation) && d(F, _, R);
  }, d = (v, R, h) => {
    t("update-month-year", { month: v, year: R, fromNav: h });
  }, P = j(() => (v) => Nn(
    Se(H(), { month: e.month, year: e.year }),
    n.value.maxDate,
    n.value.minDate,
    e.preventMinMaxNavigation,
    v
  ));
  return { handleMonthYearChange: g, isDisabled: P, updateMonthYear: d };
}, va = {
  multiCalendars: { type: [Boolean, Number, String, Object], default: void 0 },
  modelValue: { type: [String, Date, Array, Object, Number], default: null },
  modelType: { type: String, default: null },
  position: { type: String, default: "center" },
  dark: { type: Boolean, default: !1 },
  format: {
    type: [String, Function],
    default: () => null
  },
  autoPosition: { type: [Boolean, String], default: !0 },
  altPosition: { type: Function, default: null },
  transitions: { type: [Boolean, Object], default: !0 },
  formatLocale: { type: Object, default: null },
  utc: { type: [Boolean, String], default: !1 },
  ariaLabels: { type: Object, default: () => ({}) },
  offset: { type: [Number, String], default: 10 },
  hideNavigation: { type: Array, default: () => [] },
  timezone: { type: [String, Object], default: null },
  vertical: { type: Boolean, default: !1 },
  disableMonthYearSelect: { type: Boolean, default: !1 },
  disableYearSelect: { type: Boolean, default: !1 },
  dayClass: {
    type: Function,
    default: null
  },
  yearRange: { type: Array, default: () => [1900, 2100] },
  enableTimePicker: { type: Boolean, default: !0 },
  autoApply: { type: Boolean, default: !1 },
  disabledDates: { type: [Array, Function], default: () => [] },
  monthNameFormat: { type: String, default: "short" },
  startDate: { type: [Date, String], default: null },
  startTime: { type: [Object, Array], default: null },
  hideOffsetDates: { type: Boolean, default: !1 },
  noToday: { type: Boolean, default: !1 },
  disabledWeekDays: { type: Array, default: () => [] },
  allowedDates: { type: Array, default: null },
  nowButtonLabel: { type: String, default: "Now" },
  markers: { type: Array, default: () => [] },
  escClose: { type: Boolean, default: !0 },
  spaceConfirm: { type: Boolean, default: !0 },
  monthChangeOnArrows: { type: Boolean, default: !0 },
  presetDates: { type: Array, default: () => [] },
  flow: { type: Array, default: () => [] },
  partialFlow: { type: Boolean, default: !1 },
  preventMinMaxNavigation: { type: Boolean, default: !1 },
  reverseYears: { type: Boolean, default: !1 },
  weekPicker: { type: Boolean, default: !1 },
  filters: { type: Object, default: () => ({}) },
  arrowNavigation: { type: Boolean, default: !1 },
  highlight: {
    type: [Function, Object],
    default: null
  },
  teleport: { type: [Boolean, String, Object], default: null },
  teleportCenter: { type: Boolean, default: !1 },
  locale: { type: String, default: "en-Us" },
  weekNumName: { type: String, default: "W" },
  weekStart: { type: [Number, String], default: 1 },
  weekNumbers: {
    type: [String, Function, Object],
    default: null
  },
  monthChangeOnScroll: { type: [Boolean, String], default: !0 },
  dayNames: {
    type: [Function, Array],
    default: null
  },
  monthPicker: { type: Boolean, default: !1 },
  customProps: { type: Object, default: null },
  yearPicker: { type: Boolean, default: !1 },
  modelAuto: { type: Boolean, default: !1 },
  selectText: { type: String, default: "Select" },
  cancelText: { type: String, default: "Cancel" },
  previewFormat: {
    type: [String, Function],
    default: () => ""
  },
  multiDates: { type: [Object, Boolean], default: !1 },
  ignoreTimeValidation: { type: Boolean, default: !1 },
  minDate: { type: [Date, String], default: null },
  maxDate: { type: [Date, String], default: null },
  minTime: { type: Object, default: null },
  maxTime: { type: Object, default: null },
  name: { type: String, default: null },
  placeholder: { type: String, default: "" },
  hideInputIcon: { type: Boolean, default: !1 },
  clearable: { type: Boolean, default: !0 },
  alwaysClearable: { type: Boolean, default: !1 },
  state: { type: Boolean, default: null },
  required: { type: Boolean, default: !1 },
  autocomplete: { type: String, default: "off" },
  timePicker: { type: Boolean, default: !1 },
  enableSeconds: { type: Boolean, default: !1 },
  is24: { type: Boolean, default: !0 },
  noHoursOverlay: { type: Boolean, default: !1 },
  noMinutesOverlay: { type: Boolean, default: !1 },
  noSecondsOverlay: { type: Boolean, default: !1 },
  hoursGridIncrement: { type: [String, Number], default: 1 },
  minutesGridIncrement: { type: [String, Number], default: 5 },
  secondsGridIncrement: { type: [String, Number], default: 5 },
  hoursIncrement: { type: [Number, String], default: 1 },
  minutesIncrement: { type: [Number, String], default: 1 },
  secondsIncrement: { type: [Number, String], default: 1 },
  range: { type: [Boolean, Object], default: !1 },
  uid: { type: String, default: null },
  disabled: { type: Boolean, default: !1 },
  readonly: { type: Boolean, default: !1 },
  inline: { type: [Boolean, Object], default: !1 },
  textInput: { type: [Boolean, Object], default: !1 },
  sixWeeks: { type: [Boolean, String], default: !1 },
  actionRow: { type: Object, default: () => ({}) },
  focusStartDate: { type: Boolean, default: !1 },
  disabledTimes: { type: [Function, Array], default: void 0 },
  timePickerInline: { type: Boolean, default: !1 },
  calendar: { type: Function, default: null },
  config: { type: Object, default: void 0 },
  quarterPicker: { type: Boolean, default: !1 },
  yearFirst: { type: Boolean, default: !1 },
  loading: { type: Boolean, default: !1 },
  onInternalModelChange: { type: [Function, Object], default: null },
  enableMinutes: { type: Boolean, default: !0 },
  ui: { type: Object, default: () => ({}) }
}, dt = {
  ...va,
  shadow: { type: Boolean, default: !1 },
  flowStep: { type: Number, default: 0 },
  internalModelValue: { type: [Date, Array], default: null },
  noOverlayFocus: { type: Boolean, default: !1 },
  collapse: { type: Boolean, default: !1 },
  menuWrapRef: { type: Object, default: null },
  getInputRect: { type: Function, default: () => ({}) },
  isTextInputDate: { type: Boolean, default: !1 },
  isMobile: { type: Boolean, default: void 0 }
}, sr = ["title"], ur = ["disabled"], ir = /* @__PURE__ */ We({
  compatConfig: {
    MODE: 3
  },
  __name: "ActionRow",
  props: {
    menuMount: { type: Boolean, default: !1 },
    calendarWidth: { type: Number, default: 0 },
    ...dt
  },
  emits: ["close-picker", "select-date", "select-now", "invalid-select"],
  setup(e, { emit: t }) {
    const l = t, n = e, {
      defaultedActionRow: a,
      defaultedPreviewFormat: f,
      defaultedMultiCalendars: i,
      defaultedTextInput: g,
      defaultedInline: d,
      defaultedRange: P,
      defaultedMultiDates: v
    } = Oe(n), { isTimeValid: R, isMonthValid: h } = Tt(n), { buildMatrix: T } = At(), F = Z(null), _ = Z(null), C = Z(!1), M = Z({}), A = Z(null), m = Z(null);
    Ue(() => {
      n.arrowNavigation && T([Le(F), Le(_)], "actionRow"), z(), window.addEventListener("resize", z);
    }), Ut(() => {
      window.removeEventListener("resize", z);
    });
    const z = () => {
      C.value = !1, setTimeout(() => {
        const p = A.value?.getBoundingClientRect(), Y = m.value?.getBoundingClientRect();
        p && Y && (M.value.maxWidth = `${Y.width - p.width - 20}px`), C.value = !0;
      }, 0);
    }, L = j(() => P.value.enabled && !P.value.partialRange && n.internalModelValue ? n.internalModelValue.length === 2 : !0), le = j(
      () => !R.value(n.internalModelValue) || !h.value(n.internalModelValue) || !L.value
    ), U = () => {
      const p = f.value;
      return n.timePicker || n.monthPicker, p(Ne(n.internalModelValue));
    }, $ = () => {
      const p = n.internalModelValue;
      return i.value.count > 0 ? `${ee(p[0])} - ${ee(p[1])}` : [ee(p[0]), ee(p[1])];
    }, ee = (p) => Ln(
      p,
      f.value,
      n.formatLocale,
      g.value.rangeSeparator,
      n.modelAuto,
      f.value
    ), O = j(() => !n.internalModelValue || !n.menuMount ? "" : typeof f.value == "string" ? Array.isArray(n.internalModelValue) ? n.internalModelValue.length === 2 && n.internalModelValue[1] ? $() : v.value.enabled ? n.internalModelValue.map((p) => `${ee(p)}`) : n.modelAuto ? `${ee(n.internalModelValue[0])}` : `${ee(n.internalModelValue[0])} -` : ee(n.internalModelValue) : U()), J = () => v.value.enabled ? "; " : " - ", ce = j(
      () => Array.isArray(O.value) ? O.value.join(J()) : O.value
    ), pe = () => {
      R.value(n.internalModelValue) && h.value(n.internalModelValue) && L.value ? l("select-date") : l("invalid-select");
    };
    return (p, Y) => (w(), W("div", {
      ref_key: "actionRowRef",
      ref: m,
      class: "dp__action_row"
    }, [
      p.$slots["action-row"] ? ie(p.$slots, "action-row", ze(He({ key: 0 }, {
        internalModelValue: p.internalModelValue,
        disabled: le.value,
        selectDate: () => p.$emit("select-date"),
        closePicker: () => p.$emit("close-picker")
      }))) : (w(), W(ke, { key: 1 }, [
        s(a).showPreview ? (w(), W("div", {
          key: 0,
          class: "dp__selection_preview",
          title: ce.value,
          style: lt(M.value)
        }, [
          p.$slots["action-preview"] && C.value ? ie(p.$slots, "action-preview", {
            key: 0,
            value: p.internalModelValue
          }) : Q("", !0),
          !p.$slots["action-preview"] && C.value ? (w(), W(ke, { key: 1 }, [
            gt(Ke(ce.value), 1)
          ], 64)) : Q("", !0)
        ], 12, sr)) : Q("", !0),
        he("div", {
          ref_key: "actionBtnContainer",
          ref: A,
          class: "dp__action_buttons",
          "data-dp-element": "action-row"
        }, [
          p.$slots["action-buttons"] ? ie(p.$slots, "action-buttons", {
            key: 0,
            value: p.internalModelValue
          }) : Q("", !0),
          p.$slots["action-buttons"] ? Q("", !0) : (w(), W(ke, { key: 1 }, [
            !s(d).enabled && s(a).showCancel ? (w(), W("button", {
              key: 0,
              ref_key: "cancelButtonRef",
              ref: F,
              type: "button",
              class: "dp__action_button dp__action_cancel",
              onClick: Y[0] || (Y[0] = (te) => p.$emit("close-picker")),
              onKeydown: Y[1] || (Y[1] = (te) => s(qe)(te, () => p.$emit("close-picker")))
            }, Ke(p.cancelText), 545)) : Q("", !0),
            s(a).showNow ? (w(), W("button", {
              key: 1,
              type: "button",
              class: "dp__action_button dp__action_cancel",
              onClick: Y[2] || (Y[2] = (te) => p.$emit("select-now")),
              onKeydown: Y[3] || (Y[3] = (te) => s(qe)(te, () => p.$emit("select-now")))
            }, Ke(p.nowButtonLabel), 33)) : Q("", !0),
            s(a).showSelect ? (w(), W("button", {
              key: 2,
              ref_key: "selectButtonRef",
              ref: _,
              type: "button",
              class: "dp__action_button dp__action_select",
              disabled: le.value,
              "data-test-id": "select-button",
              onKeydown: Y[4] || (Y[4] = (te) => s(qe)(te, () => pe())),
              onClick: pe
            }, Ke(p.selectText), 41, ur)) : Q("", !0)
          ], 64))
        ], 512)
      ], 64))
    ], 512));
  }
}), dr = ["role", "aria-label", "tabindex"], cr = { class: "dp__selection_grid_header" }, fr = ["aria-selected", "aria-disabled", "data-test-id", "onClick", "onKeydown", "onMouseover"], vr = ["aria-label"], ta = /* @__PURE__ */ We({
  __name: "SelectionOverlay",
  props: {
    items: {},
    type: {},
    isLast: { type: Boolean },
    arrowNavigation: { type: Boolean },
    skipButtonRef: { type: Boolean },
    headerRefs: {},
    hideNavigation: {},
    escClose: { type: Boolean },
    useRelative: { type: Boolean },
    height: {},
    textInput: { type: [Boolean, Object] },
    config: {},
    noOverlayFocus: { type: Boolean },
    focusValue: {},
    menuWrapRef: {},
    ariaLabels: {},
    overlayLabel: {}
  },
  emits: ["selected", "toggle", "reset-flow", "hover-value"],
  setup(e, { expose: t, emit: l }) {
    const { setSelectionGrid: n, buildMultiLevelMatrix: a, setMonthPicker: f } = At(), i = l, g = e, { defaultedAriaLabels: d, defaultedTextInput: P, defaultedConfig: v, handleEventPropagation: R } = Oe(
      g
    ), { hideNavigationButtons: h } = ga(), T = Z(!1), F = Z(null), _ = Z(null), C = Z([]), M = Z(), A = Z(null), m = Z(0), z = Z(null);
    Zn(() => {
      F.value = null;
    }), Ue(() => {
      at().then(() => ce()), g.noOverlayFocus || le(), L(!0);
    }), Ut(() => L(!1));
    const L = (u) => {
      g.arrowNavigation && (g.headerRefs?.length ? f(u) : n(u));
    }, le = () => {
      const u = Le(_);
      u && (P.value.enabled || (F.value ? F.value?.focus({ preventScroll: !0 }) : u.focus({ preventScroll: !0 })), T.value = u.clientHeight < u.scrollHeight);
    }, U = j(
      () => ({
        dp__overlay: !0,
        "dp--overlay-absolute": !g.useRelative,
        "dp--overlay-relative": g.useRelative
      })
    ), $ = j(
      () => g.useRelative ? { height: `${g.height}px`, width: "var(--dp-menu-min-width)" } : void 0
    ), ee = j(() => ({
      dp__overlay_col: !0
    })), O = j(
      () => ({
        dp__btn: !0,
        dp__button: !0,
        dp__overlay_action: !0,
        dp__over_action_scroll: T.value,
        dp__button_bottom: g.isLast
      })
    ), J = j(() => ({
      dp__overlay_container: !0,
      dp__container_flex: g.items?.length <= 6,
      dp__container_block: g.items?.length > 6
    }));
    rt(
      () => g.items,
      () => ce(!1),
      { deep: !0 }
    );
    const ce = (u = !0) => {
      at().then(() => {
        const re = Le(F), G = Le(_), I = Le(A), x = Le(z), c = I ? I.getBoundingClientRect().height : 0;
        G && (G.getBoundingClientRect().height ? m.value = G.getBoundingClientRect().height - c : m.value = v.value.modeHeight - c), re && x && u && (x.scrollTop = re.offsetTop - x.offsetTop - (m.value / 2 - re.getBoundingClientRect().height) - c);
      });
    }, pe = (u) => {
      u.disabled || i("selected", u.value);
    }, p = () => {
      i("toggle"), i("reset-flow");
    }, Y = (u) => {
      g.escClose && (p(), R(u));
    }, te = (u, re, G, I) => {
      u && ((re.active || re.value === g.focusValue) && (F.value = u), g.arrowNavigation && (Array.isArray(C.value[G]) ? C.value[G][I] = u : C.value[G] = [u], y()));
    }, y = () => {
      const u = g.headerRefs?.length ? [g.headerRefs].concat(C.value) : C.value.concat([g.skipButtonRef ? [] : [A.value]]);
      a(Ne(u), g.headerRefs?.length ? "monthPicker" : "selectionGrid");
    }, V = (u) => {
      g.arrowNavigation || Dt(u, v.value, !0);
    }, S = (u) => {
      M.value = u, i("hover-value", u);
    }, q = () => {
      if (p(), !g.isLast) {
        const u = Fa(g.menuWrapRef ?? null, "action-row");
        u && Cn(u)?.focus();
      }
    }, k = (u) => {
      switch (u.key) {
        case Re.esc:
          return Y(u);
        case Re.arrowLeft:
          return V(u);
        case Re.arrowRight:
          return V(u);
        case Re.arrowUp:
          return V(u);
        case Re.arrowDown:
          return V(u);
        default:
          return;
      }
    }, se = (u) => {
      if (u.key === Re.enter) return p();
      if (u.key === Re.tab) return q();
    };
    return t({ focusGrid: le }), (u, re) => (w(), W("div", {
      ref_key: "gridWrapRef",
      ref: _,
      class: De(U.value),
      style: lt($.value),
      role: e.useRelative ? void 0 : "dialog",
      "aria-label": e.overlayLabel,
      tabindex: e.useRelative ? void 0 : "0",
      onKeydown: k,
      onClick: re[0] || (re[0] = Xt(() => {
      }, ["prevent"]))
    }, [
      he("div", {
        ref_key: "containerRef",
        ref: z,
        class: De(J.value),
        style: lt({ "--dp-overlay-height": `${m.value}px` }),
        role: "grid"
      }, [
        he("div", cr, [
          ie(u.$slots, "header")
        ]),
        u.$slots.overlay ? ie(u.$slots, "overlay", { key: 0 }) : (w(!0), W(ke, { key: 1 }, Ce(e.items, (G, I) => (w(), W("div", {
          key: I,
          class: De(["dp__overlay_row", { dp__flex_row: e.items.length >= 3 }]),
          role: "row"
        }, [
          (w(!0), W(ke, null, Ce(G, (x, c) => (w(), W("div", {
            key: x.value,
            ref_for: !0,
            ref: (o) => te(o, x, I, c),
            role: "gridcell",
            class: De(ee.value),
            "aria-selected": x.active || void 0,
            "aria-disabled": x.disabled || void 0,
            tabindex: "0",
            "data-test-id": x.text,
            onClick: Xt((o) => pe(x), ["prevent"]),
            onKeydown: (o) => s(qe)(o, () => pe(x), !0),
            onMouseover: (o) => S(x.value)
          }, [
            he("div", {
              class: De(x.className)
            }, [
              u.$slots.item ? ie(u.$slots, "item", {
                key: 0,
                item: x
              }) : Q("", !0),
              u.$slots.item ? Q("", !0) : (w(), W(ke, { key: 1 }, [
                gt(Ke(x.text), 1)
              ], 64))
            ], 2)
          ], 42, fr))), 128))
        ], 2))), 128))
      ], 6),
      u.$slots["button-icon"] ? ua((w(), W("button", {
        key: 0,
        ref_key: "toggleButton",
        ref: A,
        type: "button",
        "aria-label": s(d)?.toggleOverlay,
        class: De(O.value),
        tabindex: "0",
        onClick: p,
        onKeydown: se
      }, [
        ie(u.$slots, "button-icon")
      ], 42, vr)), [
        [ia, !s(h)(e.hideNavigation, e.type)]
      ]) : Q("", !0)
    ], 46, dr));
  }
}), mr = ["data-dp-mobile"], ma = /* @__PURE__ */ We({
  __name: "InstanceWrap",
  props: {
    multiCalendars: {},
    stretch: { type: Boolean },
    collapse: { type: Boolean },
    isMobile: { type: Boolean }
  },
  setup(e) {
    const t = e, l = j(
      () => t.multiCalendars > 0 ? [...Array(t.multiCalendars).keys()] : [0]
    ), n = j(() => ({
      dp__instance_calendar: t.multiCalendars > 0
    }));
    return (a, f) => (w(), W("div", {
      class: De({
        dp__menu_inner: !e.stretch,
        "dp--menu--inner-stretched": e.stretch,
        dp__flex_display: e.multiCalendars > 0,
        "dp--flex-display-collapsed": e.collapse
      }),
      "data-dp-mobile": e.isMobile
    }, [
      (w(!0), W(ke, null, Ce(l.value, (i, g) => (w(), W("div", {
        key: i,
        class: De(n.value)
      }, [
        ie(a.$slots, "default", {
          instance: i,
          index: g
        })
      ], 2))), 128))
    ], 10, mr));
  }
}), pr = ["data-dp-element", "aria-label", "aria-disabled"], Qt = /* @__PURE__ */ We({
  compatConfig: {
    MODE: 3
  },
  __name: "ArrowBtn",
  props: {
    ariaLabel: {},
    elName: {},
    disabled: { type: Boolean }
  },
  emits: ["activate", "set-ref"],
  setup(e, { emit: t }) {
    const l = t, n = Z(null);
    return Ue(() => l("set-ref", n)), (a, f) => (w(), W("button", {
      ref_key: "elRef",
      ref: n,
      type: "button",
      "data-dp-element": e.elName,
      class: "dp__btn dp--arrow-btn-nav",
      tabindex: "0",
      "aria-label": e.ariaLabel,
      "aria-disabled": e.disabled || void 0,
      onClick: f[0] || (f[0] = (i) => l("activate")),
      onKeydown: f[1] || (f[1] = (i) => s(qe)(i, () => l("activate"), !0))
    }, [
      he("span", {
        class: De(["dp__inner_nav", { dp__inner_nav_disabled: e.disabled }])
      }, [
        ie(a.$slots, "default")
      ], 2)
    ], 40, pr));
  }
}), gr = ["aria-label", "data-test-id"], Wn = /* @__PURE__ */ We({
  __name: "YearModePicker",
  props: {
    ...dt,
    showYearPicker: { type: Boolean, default: !1 },
    items: { type: Array, default: () => [] },
    instance: { type: Number, default: 0 },
    year: { type: Number, default: 0 },
    isDisabled: { type: Function, default: () => !1 }
  },
  emits: ["toggle-year-picker", "year-select", "handle-year"],
  setup(e, { emit: t }) {
    const l = t, n = e, { showRightIcon: a, showLeftIcon: f } = ga(), { defaultedConfig: i, defaultedMultiCalendars: g, defaultedAriaLabels: d, defaultedTransitions: P, defaultedUI: v } = Oe(n), { showTransition: R, transitionName: h } = aa(P), T = Z(!1), F = j(() => Ja(n.year, n.locale)), _ = (A = !1, m) => {
      T.value = !T.value, l("toggle-year-picker", { flow: A, show: m });
    }, C = (A) => {
      T.value = !1, l("year-select", A);
    }, M = (A = !1) => {
      l("handle-year", A);
    };
    return (A, m) => (w(), W(ke, null, [
      he("div", {
        class: De(["dp--year-mode-picker", { "dp--hidden-el": T.value }])
      }, [
        s(f)(s(g), e.instance) ? (w(), Te(Qt, {
          key: 0,
          ref: "mpPrevIconRef",
          "aria-label": s(d)?.prevYear,
          disabled: e.isDisabled(!1),
          class: De(s(v)?.navBtnPrev),
          onActivate: m[0] || (m[0] = (z) => M(!1))
        }, {
          default: we(() => [
            A.$slots["arrow-left"] ? ie(A.$slots, "arrow-left", { key: 0 }) : Q("", !0),
            A.$slots["arrow-left"] ? Q("", !0) : (w(), Te(s(Ua), { key: 1 }))
          ]),
          _: 3
        }, 8, ["aria-label", "disabled", "class"])) : Q("", !0),
        he("button", {
          ref: "mpYearButtonRef",
          class: "dp__btn dp--year-select",
          type: "button",
          "aria-label": `${e.year}-${s(d)?.openYearsOverlay}`,
          "data-test-id": `year-mode-btn-${e.instance}`,
          onClick: m[1] || (m[1] = () => _(!1)),
          onKeydown: m[2] || (m[2] = xn(() => _(!1), ["enter"]))
        }, [
          A.$slots.year ? ie(A.$slots, "year", {
            key: 0,
            year: e.year,
            text: F.value,
            value: e.year
          }) : Q("", !0),
          A.$slots.year ? Q("", !0) : (w(), W(ke, { key: 1 }, [
            gt(Ke(F.value), 1)
          ], 64))
        ], 40, gr),
        s(a)(s(g), e.instance) ? (w(), Te(Qt, {
          key: 1,
          ref: "mpNextIconRef",
          "aria-label": s(d)?.nextYear,
          disabled: e.isDisabled(!0),
          class: De(s(v)?.navBtnNext),
          onActivate: m[3] || (m[3] = (z) => M(!0))
        }, {
          default: we(() => [
            A.$slots["arrow-right"] ? ie(A.$slots, "arrow-right", { key: 0 }) : Q("", !0),
            A.$slots["arrow-right"] ? Q("", !0) : (w(), Te(s(Va), { key: 1 }))
          ]),
          _: 3
        }, 8, ["aria-label", "disabled", "class"])) : Q("", !0)
      ], 2),
      tt(Vt, {
        name: s(h)(e.showYearPicker),
        css: s(R)
      }, {
        default: we(() => [
          e.showYearPicker ? (w(), Te(ta, {
            key: 0,
            items: e.items,
            "text-input": A.textInput,
            "esc-close": A.escClose,
            config: A.config,
            "is-last": A.autoApply && !s(i).keepActionRow,
            "hide-navigation": A.hideNavigation,
            "aria-labels": A.ariaLabels,
            "overlay-label": s(d)?.yearPicker?.(!0),
            type: "year",
            onToggle: _,
            onSelected: m[4] || (m[4] = (z) => C(z))
          }, Ge({
            "button-icon": we(() => [
              A.$slots["calendar-icon"] ? ie(A.$slots, "calendar-icon", { key: 0 }) : Q("", !0),
              A.$slots["calendar-icon"] ? Q("", !0) : (w(), Te(s(jt), { key: 1 }))
            ]),
            _: 2
          }, [
            A.$slots["year-overlay-value"] ? {
              name: "item",
              fn: we(({ item: z }) => [
                ie(A.$slots, "year-overlay-value", {
                  text: z.text,
                  value: z.value
                })
              ]),
              key: "0"
            } : void 0
          ]), 1032, ["items", "text-input", "esc-close", "config", "is-last", "hide-navigation", "aria-labels", "overlay-label"])) : Q("", !0)
        ]),
        _: 3
      }, 8, ["name", "css"])
    ], 64));
  }
}), en = (e, t, l) => {
  if (t.value && Array.isArray(t.value))
    if (t.value.some((n) => $e(e, n))) {
      const n = t.value.filter((a) => !$e(a, e));
      t.value = n.length ? n : null;
    } else (l && +l > t.value.length || !l) && t.value.push(e);
  else
    t.value = [e];
}, tn = (e, t, l) => {
  let n = e.value ? e.value.slice() : [];
  return n.length === 2 && n[1] !== null && (n = []), n.length ? (Be(t, n[0]) ? n.unshift(t) : n[1] = t, l("range-end", t)) : (n = [t], l("range-start", t)), n;
}, pa = (e, t, l, n) => {
  e && (e[0] && e[1] && l && t("auto-apply"), e[0] && !e[1] && n && l && t("auto-apply"));
}, Un = (e) => {
  Array.isArray(e.value) && e.value.length <= 2 && e.range ? e.modelValue.value = e.value.map((t) => Ze(H(t), e.timezone)) : Array.isArray(e.value) || (e.modelValue.value = Ze(H(e.value), e.timezone));
}, Vn = (e, t, l, n) => Array.isArray(t.value) && (t.value.length === 2 || t.value.length === 1 && n.value.partialRange) ? n.value.fixedStart && (Ee(e, t.value[0]) || $e(e, t.value[0])) ? [t.value[0], e] : n.value.fixedEnd && (Be(e, t.value[1]) || $e(e, t.value[1])) ? [e, t.value[1]] : (l("invalid-fixed-range", e), t.value) : [], jn = ({
  multiCalendars: e,
  range: t,
  highlight: l,
  propDates: n,
  calendars: a,
  modelValue: f,
  props: i,
  filters: g,
  year: d,
  month: P,
  emit: v
}) => {
  const R = j(() => qa(i.yearRange, i.locale, i.reverseYears)), h = Z([!1]), T = j(() => (O, J) => {
    const ce = Se(it(/* @__PURE__ */ new Date()), {
      month: P.value(O),
      year: d.value(O)
    }), pe = J ? An(ce) : Gt(ce);
    return Nn(
      pe,
      n.value.maxDate,
      n.value.minDate,
      i.preventMinMaxNavigation,
      J
    );
  }), F = () => Array.isArray(f.value) && e.value.solo && f.value[1], _ = () => {
    for (let O = 0; O < e.value.count; O++)
      if (O === 0)
        a.value[O] = a.value[0];
      else if (O === e.value.count - 1 && F())
        a.value[O] = {
          month: Me(f.value[1]),
          year: ye(f.value[1])
        };
      else {
        const J = Se(H(), a.value[O - 1]);
        a.value[O] = { month: Me(J), year: ye(Mn(J, 1)) };
      }
  }, C = (O) => {
    if (!O) return _();
    const J = Se(H(), a.value[O]);
    return a.value[0].year = ye($n(J, e.value.count - 1)), _();
  }, M = (O, J) => {
    const ce = vl(J, O);
    return t.value.showLastInRange && ce > 1 ? J : O;
  }, A = (O) => i.focusStartDate || e.value.solo ? O[0] : O[1] ? M(O[0], O[1]) : O[0], m = () => {
    if (f.value) {
      const O = Array.isArray(f.value) ? A(f.value) : f.value;
      a.value[0] = { month: Me(O), year: ye(O) };
    }
  }, z = () => {
    m(), e.value.count && _();
  };
  rt(f, (O, J) => {
    i.isTextInputDate && JSON.stringify(O ?? {}) !== JSON.stringify(J ?? {}) && z();
  }), Ue(() => {
    z();
  });
  const L = (O, J) => {
    a.value[J].year = O, v("update-month-year", { instance: J, year: O, month: a.value[J].month }), e.value.count && !e.value.solo && C(J);
  }, le = j(() => (O) => Ht(R.value, (J) => {
    const ce = d.value(O) === J.value, pe = Zt(
      J.value,
      Wt(n.value.minDate),
      Wt(n.value.maxDate)
    ) || g.value.years?.includes(d.value(O)), p = xa(l.value, J.value);
    return { active: ce, disabled: pe, highlighted: p };
  })), U = (O, J) => {
    L(O, J), ee(J);
  }, $ = (O, J = !1) => {
    if (!T.value(O, J)) {
      const ce = J ? d.value(O) + 1 : d.value(O) - 1;
      L(ce, O);
    }
  }, ee = (O, J = !1, ce) => {
    J || v("reset-flow"), ce !== void 0 ? h.value[O] = ce : h.value[O] = !h.value[O], h.value[O] ? v("overlay-toggle", { open: !0, overlay: je.year }) : (v("overlay-closed"), v("overlay-toggle", { open: !1, overlay: je.year }));
  };
  return {
    isDisabled: T,
    groupedYears: le,
    showYearPicker: h,
    selectYear: L,
    toggleYearPicker: ee,
    handleYearSelect: U,
    handleYear: $
  };
}, yr = (e, t) => {
  const {
    defaultedMultiCalendars: l,
    defaultedAriaLabels: n,
    defaultedTransitions: a,
    defaultedConfig: f,
    defaultedRange: i,
    defaultedHighlight: g,
    propDates: d,
    defaultedTz: P,
    defaultedFilters: v,
    defaultedMultiDates: R
  } = Oe(e), h = () => {
    e.isTextInputDate && z(ye(H(e.startDate)), 0);
  }, { modelValue: T, year: F, month: _, calendars: C } = na(e, t, h), M = j(() => Pn(e.formatLocale, e.locale, e.monthNameFormat)), A = Z(null), { checkMinMaxRange: m } = Tt(e), {
    selectYear: z,
    groupedYears: L,
    showYearPicker: le,
    toggleYearPicker: U,
    handleYearSelect: $,
    handleYear: ee,
    isDisabled: O
  } = jn({
    modelValue: T,
    multiCalendars: l,
    range: i,
    highlight: g,
    calendars: C,
    year: F,
    propDates: d,
    month: _,
    filters: v,
    props: e,
    emit: t
  });
  Ue(() => {
    e.startDate && (T.value && e.focusStartDate || !T.value) && z(ye(H(e.startDate)), 0);
  });
  const J = (I) => I ? { month: Me(I), year: ye(I) } : { month: null, year: null }, ce = () => T.value ? Array.isArray(T.value) ? T.value.map((I) => J(I)) : J(T.value) : J(), pe = (I, x) => {
    const c = C.value[I], o = ce();
    return Array.isArray(o) ? o.some((X) => X.year === c?.year && X.month === x) : c?.year === o.year && x === o.month;
  }, p = (I, x, c) => {
    const o = ce();
    return Array.isArray(o) ? F.value(x) === o[c]?.year && I === o[c]?.month : !1;
  }, Y = (I, x) => {
    if (i.value.enabled) {
      const c = ce();
      if (Array.isArray(T.value) && Array.isArray(c)) {
        const o = p(I, x, 0) || p(I, x, 1), X = pt(it(H()), I, F.value(x));
        return xt(T.value, A.value, X) && !o;
      }
      return !1;
    }
    return !1;
  }, te = j(() => (I) => Ht(M.value, (x) => {
    const c = pe(I, x.value), o = Zt(
      x.value,
      _n(F.value(I), d.value.minDate),
      Yn(F.value(I), d.value.maxDate)
    ) || zl(d.value.disabledDates, F.value(I), x.value) || v.value.months?.includes(x.value) || !Hl(d.value.allowedDates, F.value(I), x.value) || zn(e.yearRange, F.value(I)), X = Y(x.value, I), B = Fn(g.value, x.value, F.value(I));
    return { active: c, disabled: o, isBetween: X, highlighted: B };
  })), y = (I, x) => pt(it(H()), I, F.value(x)), V = (I, x) => {
    const c = T.value ? T.value : it(/* @__PURE__ */ new Date());
    T.value = pt(c, I, F.value(x)), t("auto-apply"), t("update-flow-step");
  }, S = (I, x) => {
    const c = y(I, x);
    i.value.fixedEnd || i.value.fixedStart ? T.value = Vn(c, T, t, i) : T.value ? m(c, T.value) && (T.value = tn(T, y(I, x), t)) : T.value = [y(I, x)], at().then(() => {
      pa(T.value, t, e.autoApply, e.modelAuto);
    });
  }, q = (I, x) => {
    en(y(I, x), T, R.value.limit), t("auto-apply", !0);
  }, k = (I, x) => (C.value[x].month = I, u(x, C.value[x].year, I), R.value.enabled ? q(I, x) : i.value.enabled ? S(I, x) : V(I, x)), se = (I, x) => {
    z(I, x), u(x, I, null);
  }, u = (I, x, c) => {
    let o = c;
    if (!o && o !== 0) {
      const X = ce();
      o = Array.isArray(X) ? X[I].month : X.month;
    }
    t("update-month-year", { instance: I, year: x, month: o });
  };
  return {
    groupedMonths: te,
    groupedYears: L,
    year: F,
    isDisabled: O,
    defaultedMultiCalendars: l,
    defaultedAriaLabels: n,
    defaultedTransitions: a,
    defaultedConfig: f,
    showYearPicker: le,
    modelValue: T,
    presetDate: (I, x) => {
      Un({
        value: I,
        modelValue: T,
        range: i.value.enabled,
        timezone: x ? void 0 : P.value.timezone
      }), t("auto-apply");
    },
    setHoverDate: (I, x) => {
      A.value = y(I, x);
    },
    selectMonth: k,
    selectYear: se,
    toggleYearPicker: U,
    handleYearSelect: $,
    handleYear: ee,
    getModelMonthYear: ce
  };
}, hr = /* @__PURE__ */ We({
  compatConfig: {
    MODE: 3
  },
  __name: "MonthPicker",
  props: {
    ...dt
  },
  emits: [
    "update:internal-model-value",
    "overlay-closed",
    "reset-flow",
    "range-start",
    "range-end",
    "auto-apply",
    "update-month-year",
    "update-flow-step",
    "mount",
    "invalid-fixed-range",
    "overlay-toggle"
  ],
  setup(e, { expose: t, emit: l }) {
    const n = l, a = Yt(), f = et(a, "yearMode"), i = e;
    Ue(() => {
      i.shadow || n("mount", null);
    });
    const {
      groupedMonths: g,
      groupedYears: d,
      year: P,
      isDisabled: v,
      defaultedMultiCalendars: R,
      defaultedConfig: h,
      showYearPicker: T,
      modelValue: F,
      presetDate: _,
      setHoverDate: C,
      selectMonth: M,
      selectYear: A,
      toggleYearPicker: m,
      handleYearSelect: z,
      handleYear: L,
      getModelMonthYear: le
    } = yr(i, n);
    return t({ getSidebarProps: () => ({
      modelValue: F,
      year: P,
      getModelMonthYear: le,
      selectMonth: M,
      selectYear: A,
      handleYear: L
    }), presetDate: _, toggleYearPicker: ($) => m(0, $) }), ($, ee) => (w(), Te(ma, {
      "multi-calendars": s(R).count,
      collapse: $.collapse,
      stretch: "",
      "is-mobile": $.isMobile
    }, {
      default: we(({ instance: O }) => [
        $.$slots["top-extra"] ? ie($.$slots, "top-extra", {
          key: 0,
          value: $.internalModelValue
        }) : Q("", !0),
        $.$slots["month-year"] ? ie($.$slots, "month-year", ze(He({ key: 1 }, {
          year: s(P),
          months: s(g)(O),
          years: s(d)(O),
          selectMonth: s(M),
          selectYear: s(A),
          instance: O
        }))) : (w(), Te(ta, {
          key: 2,
          items: s(g)(O),
          "arrow-navigation": $.arrowNavigation,
          "is-last": $.autoApply && !s(h).keepActionRow,
          "esc-close": $.escClose,
          height: s(h).modeHeight,
          config: $.config,
          "no-overlay-focus": !!($.noOverlayFocus || $.textInput),
          "use-relative": "",
          type: "month",
          onSelected: (J) => s(M)(J, O),
          onHoverValue: (J) => s(C)(J, O)
        }, Ge({
          header: we(() => [
            tt(Wn, He($.$props, {
              items: s(d)(O),
              instance: O,
              "show-year-picker": s(T)[O],
              year: s(P)(O),
              "is-disabled": (J) => s(v)(O, J),
              onHandleYear: (J) => s(L)(O, J),
              onYearSelect: (J) => s(z)(J, O),
              onToggleYearPicker: (J) => s(m)(O, J?.flow, J?.show)
            }), Ge({ _: 2 }, [
              Ce(s(f), (J, ce) => ({
                name: J,
                fn: we((pe) => [
                  ie($.$slots, J, ze(Je(pe)))
                ])
              }))
            ]), 1040, ["items", "instance", "show-year-picker", "year", "is-disabled", "onHandleYear", "onYearSelect", "onToggleYearPicker"])
          ]),
          _: 2
        }, [
          $.$slots["month-overlay-value"] ? {
            name: "item",
            fn: we(({ item: J }) => [
              ie($.$slots, "month-overlay-value", {
                text: J.text,
                value: J.value
              })
            ]),
            key: "0"
          } : void 0
        ]), 1032, ["items", "arrow-navigation", "is-last", "esc-close", "height", "config", "no-overlay-focus", "onSelected", "onHoverValue"]))
      ]),
      _: 3
    }, 8, ["multi-calendars", "collapse", "is-mobile"]));
  }
}), br = (e, t) => {
  const l = () => {
    e.isTextInputDate && (v.value = ye(H(e.startDate)));
  }, { modelValue: n } = na(e, t, l), a = Z(null), { defaultedHighlight: f, defaultedMultiDates: i, defaultedFilters: g, defaultedRange: d, propDates: P } = Oe(e), v = Z();
  Ue(() => {
    e.startDate && (n.value && e.focusStartDate || !n.value) && (v.value = ye(H(e.startDate)));
  });
  const R = (m) => Array.isArray(n.value) ? n.value.some((z) => ye(z) === m) : n.value ? ye(n.value) === m : !1, h = (m) => d.value.enabled && Array.isArray(n.value) ? xt(n.value, a.value, C(m)) : !1, T = (m) => P.value.allowedDates instanceof Map ? P.value.allowedDates.size ? P.value.allowedDates.has(`${m}`) : !1 : !0, F = (m) => P.value.disabledDates instanceof Map ? P.value.disabledDates.size ? P.value.disabledDates.has(`${m}`) : !1 : typeof P.value.disabledDates == "function" ? P.value.disabledDates(ut(Fe(Gt(H())), m)) : !0, _ = j(() => Ht(qa(e.yearRange, e.locale, e.reverseYears), (m) => {
    const z = R(m.value), L = Zt(
      m.value,
      Wt(P.value.minDate),
      Wt(P.value.maxDate)
    ) || g.value.years.includes(m.value) || !T(m.value) || F(m.value), le = h(m.value) && !z, U = xa(f.value, m.value);
    return { active: z, disabled: L, isBetween: le, highlighted: U };
  })), C = (m) => ut(it(Gt(/* @__PURE__ */ new Date())), m);
  return {
    groupedYears: _,
    modelValue: n,
    focusYear: v,
    setHoverValue: (m) => {
      a.value = ut(it(/* @__PURE__ */ new Date()), m);
    },
    selectYear: (m) => {
      if (t("update-month-year", { instance: 0, year: m }), i.value.enabled)
        return n.value ? Array.isArray(n.value) && ((n.value?.map((L) => ye(L))).includes(m) ? n.value = n.value.filter((L) => ye(L) !== m) : n.value.push(ut(Fe(H()), m))) : n.value = [ut(Fe(Gt(H())), m)], t("auto-apply", !0);
      d.value.enabled ? (n.value = tn(n, C(m), t), at().then(() => {
        pa(n.value, t, e.autoApply, e.modelAuto);
      })) : (n.value = C(m), t("auto-apply"));
    }
  };
}, kr = /* @__PURE__ */ We({
  compatConfig: {
    MODE: 3
  },
  __name: "YearPicker",
  props: {
    ...dt
  },
  emits: [
    "update:internal-model-value",
    "reset-flow",
    "range-start",
    "range-end",
    "auto-apply",
    "update-month-year"
  ],
  setup(e, { expose: t, emit: l }) {
    const n = l, a = e, { groupedYears: f, modelValue: i, focusYear: g, selectYear: d, setHoverValue: P } = br(a, n), { defaultedConfig: v } = Oe(a);
    return t({ getSidebarProps: () => ({
      modelValue: i,
      selectYear: d
    }) }), (h, T) => (w(), W("div", null, [
      h.$slots["top-extra"] ? ie(h.$slots, "top-extra", {
        key: 0,
        value: h.internalModelValue
      }) : Q("", !0),
      h.$slots["month-year"] ? ie(h.$slots, "month-year", ze(He({ key: 1 }, {
        years: s(f),
        selectYear: s(d)
      }))) : (w(), Te(ta, {
        key: 2,
        items: s(f),
        "is-last": h.autoApply && !s(v).keepActionRow,
        height: s(v).modeHeight,
        config: h.config,
        "no-overlay-focus": !!(h.noOverlayFocus || h.textInput),
        "focus-value": s(g),
        type: "year",
        "use-relative": "",
        onSelected: s(d),
        onHoverValue: s(P)
      }, Ge({ _: 2 }, [
        h.$slots["year-overlay-value"] ? {
          name: "item",
          fn: we(({ item: F }) => [
            ie(h.$slots, "year-overlay-value", {
              text: F.text,
              value: F.value
            })
          ]),
          key: "0"
        } : void 0
      ]), 1032, ["items", "is-last", "height", "config", "no-overlay-focus", "focus-value", "onSelected", "onHoverValue"]))
    ]));
  }
}), wr = {
  key: 0,
  class: "dp__time_input"
}, Dr = ["data-compact", "data-collapsed"], Mr = ["data-test-id", "aria-label", "onKeydown", "onClick", "onMousedown"], $r = ["aria-label", "disabled", "data-test-id", "onKeydown", "onClick"], Ar = ["data-test-id", "aria-label", "onKeydown", "onClick", "onMousedown"], Tr = { key: 0 }, Sr = ["aria-label", "data-compact"], Pr = /* @__PURE__ */ We({
  compatConfig: {
    MODE: 3
  },
  __name: "TimeInput",
  props: {
    hours: { type: Number, default: 0 },
    minutes: { type: Number, default: 0 },
    seconds: { type: Number, default: 0 },
    closeTimePickerBtn: { type: Object, default: null },
    order: { type: Number, default: 0 },
    disabledTimesConfig: { type: Function, default: null },
    validateTime: { type: Function, default: () => !1 },
    ...dt
  },
  emits: [
    "set-hours",
    "set-minutes",
    "update:hours",
    "update:minutes",
    "update:seconds",
    "reset-flow",
    "mounted",
    "overlay-closed",
    "overlay-opened",
    "am-pm-change"
  ],
  setup(e, { expose: t, emit: l }) {
    const n = l, a = e, { setTimePickerElements: f, setTimePickerBackRef: i } = At(), {
      defaultedAriaLabels: g,
      defaultedTransitions: d,
      defaultedFilters: P,
      defaultedConfig: v,
      defaultedRange: R,
      defaultedMultiCalendars: h
    } = Oe(a), { transitionName: T, showTransition: F } = aa(d), _ = ea({
      hours: !1,
      minutes: !1,
      seconds: !1
    }), C = Z("AM"), M = Z(null), A = Z([]), m = Z(), z = Z(!1);
    Ue(() => {
      n("mounted");
    });
    const L = (r) => Se(/* @__PURE__ */ new Date(), {
      hours: r.hours,
      minutes: r.minutes,
      seconds: a.enableSeconds ? r.seconds : 0,
      milliseconds: 0
    }), le = j(
      () => (r) => S(r, a[r]) || $(r, a[r])
    ), U = j(() => ({ hours: a.hours, minutes: a.minutes, seconds: a.seconds })), $ = (r, E) => R.value.enabled && !R.value.disableTimeRangeValidation ? !a.validateTime(r, E) : !1, ee = (r, E) => {
      if (R.value.enabled && !R.value.disableTimeRangeValidation) {
        const K = E ? +a[`${r}Increment`] : -+a[`${r}Increment`], oe = a[r] + K;
        return !a.validateTime(r, oe);
      }
      return !1;
    }, O = j(() => (r) => !re(+a[r] + +a[`${r}Increment`], r) || ee(r, !0)), J = j(() => (r) => !re(+a[r] - +a[`${r}Increment`], r) || ee(r, !1)), ce = (r, E) => Tn(Se(H(), r), E), pe = (r, E) => ml(Se(H(), r), E), p = j(
      () => ({
        dp__time_col: !0,
        dp__time_col_block: !a.timePickerInline,
        dp__time_col_reg_block: !a.enableSeconds && a.is24 && !a.timePickerInline,
        dp__time_col_reg_inline: !a.enableSeconds && a.is24 && a.timePickerInline,
        dp__time_col_reg_with_button: !a.enableSeconds && !a.is24,
        dp__time_col_sec: a.enableSeconds && a.is24,
        dp__time_col_sec_with_button: a.enableSeconds && !a.is24
      })
    ), Y = j(
      () => a.timePickerInline && R.value.enabled && !h.value.count
    ), te = j(() => {
      const r = [{ type: "hours" }];
      return a.enableMinutes && r.push({ type: "", separator: !0 }, {
        type: "minutes"
      }), a.enableSeconds && r.push({ type: "", separator: !0 }, {
        type: "seconds"
      }), r;
    }), y = j(() => te.value.filter((r) => !r.separator)), V = j(() => (r) => {
      if (r === "hours") {
        const E = X(+a.hours);
        return { text: E < 10 ? `0${E}` : `${E}`, value: E };
      }
      return { text: a[r] < 10 ? `0${a[r]}` : `${a[r]}`, value: a[r] };
    }), S = (r, E) => {
      if (!a.disabledTimesConfig) return !1;
      const K = a.disabledTimesConfig(a.order, r === "hours" ? E : void 0);
      return K[r] ? !!K[r]?.includes(E) : !0;
    }, q = (r, E) => E !== "hours" || C.value === "AM" ? r : r + 12, k = (r) => {
      const E = a.is24 ? 24 : 12, K = r === "hours" ? E : 60, oe = +a[`${r}GridIncrement`], ge = r === "hours" && !a.is24 ? oe : 0, _e = [];
      for (let Ye = ge; Ye < K; Ye += oe)
        _e.push({ value: a.is24 ? Ye : q(Ye, r), text: Ye < 10 ? `0${Ye}` : `${Ye}` });
      return r === "hours" && !a.is24 && _e.unshift({ value: C.value === "PM" ? 12 : 0, text: "12" }), Ht(_e, (Ye) => ({ active: !1, disabled: P.value.times[r].includes(Ye.value) || !re(Ye.value, r) || S(r, Ye.value) || $(r, Ye.value) }));
    }, se = (r) => r >= 0 ? r : 59, u = (r) => r >= 0 ? r : 23, re = (r, E) => {
      const K = a.minTime ? L(Sa(a.minTime)) : null, oe = a.maxTime ? L(Sa(a.maxTime)) : null, ge = L(
        Sa(
          U.value,
          E,
          E === "minutes" || E === "seconds" ? se(r) : u(r)
        )
      );
      return K && oe ? (Ft(ge, oe) || Nt(ge, oe)) && (_t(ge, K) || Nt(ge, K)) : K ? _t(ge, K) || Nt(ge, K) : oe ? Ft(ge, oe) || Nt(ge, oe) : !0;
    }, G = (r) => a[`no${r[0].toUpperCase() + r.slice(1)}Overlay`], I = (r) => {
      G(r) || (_[r] = !_[r], _[r] ? (z.value = !0, n("overlay-opened", r)) : (z.value = !1, n("overlay-closed", r)));
    }, x = (r) => r === "hours" ? yt : r === "minutes" ? $t : zt, c = () => {
      m.value && clearTimeout(m.value);
    }, o = (r, E = !0, K) => {
      const oe = E ? ce : pe, ge = E ? +a[`${r}Increment`] : -+a[`${r}Increment`];
      re(+a[r] + ge, r) && n(
        `update:${r}`,
        x(r)(oe({ [r]: +a[r] }, { [r]: +a[`${r}Increment`] }))
      ), !K?.keyboard && v.value.timeArrowHoldThreshold && (m.value = setTimeout(() => {
        o(r, E);
      }, v.value.timeArrowHoldThreshold));
    }, X = (r) => a.is24 ? r : (r >= 12 ? C.value = "PM" : C.value = "AM", Sl(r)), B = () => {
      C.value === "PM" ? (C.value = "AM", n("update:hours", a.hours - 12)) : (C.value = "PM", n("update:hours", a.hours + 12)), n("am-pm-change", C.value);
    }, be = (r) => {
      _[r] = !0;
    }, Ae = (r, E, K) => {
      if (r && a.arrowNavigation) {
        Array.isArray(A.value[E]) ? A.value[E][K] = r : A.value[E] = [r];
        const oe = A.value.reduce(
          (ge, _e) => _e.map((Ye, nt) => [...ge[nt] || [], _e[nt]]),
          []
        );
        i(a.closeTimePickerBtn), M.value && (oe[1] = oe[1].concat(M.value)), f(oe, a.order);
      }
    }, ne = (r, E) => (I(r), n(`update:${r}`, E));
    return t({ openChildCmp: be }), (r, E) => r.disabled ? Q("", !0) : (w(), W("div", wr, [
      (w(!0), W(ke, null, Ce(te.value, (K, oe) => (w(), W("div", {
        key: oe,
        class: De(p.value),
        "data-compact": Y.value && !r.enableSeconds,
        "data-collapsed": Y.value && r.enableSeconds
      }, [
        K.separator ? (w(), W(ke, { key: 0 }, [
          z.value ? Q("", !0) : (w(), W(ke, { key: 0 }, [
            gt(":")
          ], 64))
        ], 64)) : (w(), W(ke, { key: 1 }, [
          he("button", {
            ref_for: !0,
            ref: (ge) => Ae(ge, oe, 0),
            type: "button",
            class: De({
              dp__btn: !0,
              dp__inc_dec_button: !r.timePickerInline,
              dp__inc_dec_button_inline: r.timePickerInline,
              dp__tp_inline_btn_top: r.timePickerInline,
              dp__inc_dec_button_disabled: O.value(K.type),
              "dp--hidden-el": z.value
            }),
            "data-test-id": `${K.type}-time-inc-btn-${a.order}`,
            "aria-label": s(g)?.incrementValue(K.type),
            tabindex: "0",
            onKeydown: (ge) => s(qe)(ge, () => o(K.type, !0, { keyboard: !0 }), !0),
            onClick: (ge) => s(v).timeArrowHoldThreshold ? void 0 : o(K.type, !0),
            onMousedown: (ge) => s(v).timeArrowHoldThreshold ? o(K.type, !0) : void 0,
            onMouseup: c
          }, [
            a.timePickerInline ? (w(), W(ke, { key: 1 }, [
              r.$slots["tp-inline-arrow-up"] ? ie(r.$slots, "tp-inline-arrow-up", { key: 0 }) : (w(), W(ke, { key: 1 }, [
                E[2] || (E[2] = he("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_l" }, null, -1)),
                E[3] || (E[3] = he("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_r" }, null, -1))
              ], 64))
            ], 64)) : (w(), W(ke, { key: 0 }, [
              r.$slots["arrow-up"] ? ie(r.$slots, "arrow-up", { key: 0 }) : Q("", !0),
              r.$slots["arrow-up"] ? Q("", !0) : (w(), Te(s(Ka), { key: 1 }))
            ], 64))
          ], 42, Mr),
          he("button", {
            ref_for: !0,
            ref: (ge) => Ae(ge, oe, 1),
            type: "button",
            "aria-label": `${V.value(K.type).text}-${s(g)?.openTpOverlay(K.type)}`,
            class: De({
              dp__time_display: !0,
              dp__time_display_block: !r.timePickerInline,
              dp__time_display_inline: r.timePickerInline,
              "dp--time-invalid": le.value(K.type),
              "dp--time-overlay-btn": !le.value(K.type),
              "dp--hidden-el": z.value
            }),
            disabled: G(K.type),
            tabindex: "0",
            "data-test-id": `${K.type}-toggle-overlay-btn-${a.order}`,
            onKeydown: (ge) => s(qe)(ge, () => I(K.type), !0),
            onClick: (ge) => I(K.type)
          }, [
            r.$slots[K.type] ? ie(r.$slots, K.type, {
              key: 0,
              text: V.value(K.type).text,
              value: V.value(K.type).value
            }) : Q("", !0),
            r.$slots[K.type] ? Q("", !0) : (w(), W(ke, { key: 1 }, [
              gt(Ke(V.value(K.type).text), 1)
            ], 64))
          ], 42, $r),
          he("button", {
            ref_for: !0,
            ref: (ge) => Ae(ge, oe, 2),
            type: "button",
            class: De({
              dp__btn: !0,
              dp__inc_dec_button: !r.timePickerInline,
              dp__inc_dec_button_inline: r.timePickerInline,
              dp__tp_inline_btn_bottom: r.timePickerInline,
              dp__inc_dec_button_disabled: J.value(K.type),
              "dp--hidden-el": z.value
            }),
            "data-test-id": `${K.type}-time-dec-btn-${a.order}`,
            "aria-label": s(g)?.decrementValue(K.type),
            tabindex: "0",
            onKeydown: (ge) => s(qe)(ge, () => o(K.type, !1, { keyboard: !0 }), !0),
            onClick: (ge) => s(v).timeArrowHoldThreshold ? void 0 : o(K.type, !1),
            onMousedown: (ge) => s(v).timeArrowHoldThreshold ? o(K.type, !1) : void 0,
            onMouseup: c
          }, [
            a.timePickerInline ? (w(), W(ke, { key: 1 }, [
              r.$slots["tp-inline-arrow-down"] ? ie(r.$slots, "tp-inline-arrow-down", { key: 0 }) : (w(), W(ke, { key: 1 }, [
                E[4] || (E[4] = he("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_l" }, null, -1)),
                E[5] || (E[5] = he("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_r" }, null, -1))
              ], 64))
            ], 64)) : (w(), W(ke, { key: 0 }, [
              r.$slots["arrow-down"] ? ie(r.$slots, "arrow-down", { key: 0 }) : Q("", !0),
              r.$slots["arrow-down"] ? Q("", !0) : (w(), Te(s(Ga), { key: 1 }))
            ], 64))
          ], 42, Ar)
        ], 64))
      ], 10, Dr))), 128)),
      r.is24 ? Q("", !0) : (w(), W("div", Tr, [
        r.$slots["am-pm-button"] ? ie(r.$slots, "am-pm-button", {
          key: 0,
          toggle: B,
          value: C.value
        }) : Q("", !0),
        r.$slots["am-pm-button"] ? Q("", !0) : (w(), W("button", {
          key: 1,
          ref_key: "amPmButton",
          ref: M,
          type: "button",
          class: "dp__pm_am_button",
          role: "button",
          "aria-label": s(g)?.amPmButton,
          tabindex: "0",
          "data-compact": Y.value,
          onClick: B,
          onKeydown: E[0] || (E[0] = (K) => s(qe)(K, () => B(), !0))
        }, Ke(C.value), 41, Sr))
      ])),
      (w(!0), W(ke, null, Ce(y.value, (K, oe) => (w(), Te(Vt, {
        key: oe,
        name: s(T)(_[K.type]),
        css: s(F)
      }, {
        default: we(() => [
          _[K.type] ? (w(), Te(ta, {
            key: 0,
            items: k(K.type),
            "is-last": r.autoApply && !s(v).keepActionRow,
            "esc-close": r.escClose,
            type: K.type,
            "text-input": r.textInput,
            config: r.config,
            "arrow-navigation": r.arrowNavigation,
            "aria-labels": r.ariaLabels,
            "overlay-label": s(g).timeOverlay?.(K.type),
            onSelected: (ge) => ne(K.type, ge),
            onToggle: (ge) => I(K.type),
            onResetFlow: E[1] || (E[1] = (ge) => r.$emit("reset-flow"))
          }, Ge({
            "button-icon": we(() => [
              r.$slots["clock-icon"] ? ie(r.$slots, "clock-icon", { key: 0 }) : Q("", !0),
              r.$slots["clock-icon"] ? Q("", !0) : (w(), Te(fa(r.timePickerInline ? s(jt) : s(ja)), { key: 1 }))
            ]),
            _: 2
          }, [
            r.$slots[`${K.type}-overlay-value`] ? {
              name: "item",
              fn: we(({ item: ge }) => [
                ie(r.$slots, `${K.type}-overlay-value`, {
                  text: ge.text,
                  value: ge.value
                })
              ]),
              key: "0"
            } : void 0,
            r.$slots[`${K.type}-overlay-header`] ? {
              name: "header",
              fn: we(() => [
                ie(r.$slots, `${K.type}-overlay-header`, {
                  toggle: () => I(K.type)
                })
              ]),
              key: "1"
            } : void 0
          ]), 1032, ["items", "is-last", "esc-close", "type", "text-input", "config", "arrow-navigation", "aria-labels", "overlay-label", "onSelected", "onToggle"])) : Q("", !0)
        ]),
        _: 2
      }, 1032, ["name", "css"]))), 128))
    ]));
  }
}), Rr = ["data-dp-mobile"], Cr = ["aria-label", "tabindex"], Or = ["role", "aria-label", "tabindex"], Br = ["aria-label"], Kn = /* @__PURE__ */ We({
  compatConfig: {
    MODE: 3
  },
  __name: "TimePicker",
  props: {
    hours: { type: [Number, Array], default: 0 },
    minutes: { type: [Number, Array], default: 0 },
    seconds: { type: [Number, Array], default: 0 },
    disabledTimesConfig: { type: Function, default: null },
    validateTime: {
      type: Function,
      default: () => !1
    },
    ...dt
  },
  emits: [
    "update:hours",
    "update:minutes",
    "update:seconds",
    "mount",
    "reset-flow",
    "overlay-opened",
    "overlay-closed",
    "am-pm-change"
  ],
  setup(e, { expose: t, emit: l }) {
    const n = l, a = e, { buildMatrix: f, setTimePicker: i } = At(), g = Yt(), { defaultedTransitions: d, defaultedAriaLabels: P, defaultedTextInput: v, defaultedConfig: R, defaultedRange: h } = Oe(a), { transitionName: T, showTransition: F } = aa(d), { hideNavigationButtons: _ } = ga(), C = Z(null), M = Z(null), A = Z([]), m = Z(null), z = Z(!1);
    Ue(() => {
      n("mount"), !a.timePicker && a.arrowNavigation ? f([Le(C.value)], "time") : i(!0, a.timePicker);
    });
    const L = j(() => h.value.enabled && a.modelAuto ? Rn(a.internalModelValue) : !0), le = Z(!1), U = (S) => ({
      hours: Array.isArray(a.hours) ? a.hours[S] : a.hours,
      minutes: Array.isArray(a.minutes) ? a.minutes[S] : a.minutes,
      seconds: Array.isArray(a.seconds) ? a.seconds[S] : a.seconds
    }), $ = j(() => {
      const S = [];
      if (h.value.enabled)
        for (let q = 0; q < 2; q++)
          S.push(U(q));
      else
        S.push(U(0));
      return S;
    }), ee = (S, q = !1, k = "") => {
      q || n("reset-flow"), le.value = S, n(S ? "overlay-opened" : "overlay-closed", je.time), a.arrowNavigation && i(S), at(() => {
        k !== "" && A.value[0] && A.value[0].openChildCmp(k);
      });
    }, O = j(() => ({
      dp__btn: !0,
      dp__button: !0,
      dp__button_bottom: a.autoApply && !R.value.keepActionRow
    })), J = et(g, "timePicker"), ce = (S, q, k) => h.value.enabled ? q === 0 ? [S, $.value[1][k]] : [$.value[0][k], S] : S, pe = (S) => {
      n("update:hours", S);
    }, p = (S) => {
      n("update:minutes", S);
    }, Y = (S) => {
      n("update:seconds", S);
    }, te = () => {
      if (m.value && !v.value.enabled && !a.noOverlayFocus) {
        const S = Cn(m.value);
        S && S.focus({ preventScroll: !0 });
      }
    }, y = (S) => {
      z.value = !1, n("overlay-closed", S);
    }, V = (S) => {
      z.value = !0, n("overlay-opened", S);
    };
    return t({ toggleTimePicker: ee }), (S, q) => (w(), W("div", {
      class: "dp--tp-wrap",
      "data-dp-mobile": S.isMobile
    }, [
      !S.timePicker && !S.timePickerInline ? ua((w(), W("button", {
        key: 0,
        ref_key: "openTimePickerBtn",
        ref: C,
        type: "button",
        class: De({ ...O.value, "dp--hidden-el": le.value }),
        "aria-label": s(P)?.openTimePicker,
        tabindex: S.noOverlayFocus ? void 0 : 0,
        "data-test-id": "open-time-picker-btn",
        onKeydown: q[0] || (q[0] = (k) => s(qe)(k, () => ee(!0))),
        onClick: q[1] || (q[1] = (k) => ee(!0))
      }, [
        S.$slots["clock-icon"] ? ie(S.$slots, "clock-icon", { key: 0 }) : Q("", !0),
        S.$slots["clock-icon"] ? Q("", !0) : (w(), Te(s(ja), { key: 1 }))
      ], 42, Cr)), [
        [ia, !s(_)(S.hideNavigation, "time")]
      ]) : Q("", !0),
      tt(Vt, {
        name: s(T)(le.value),
        css: s(F) && !S.timePickerInline
      }, {
        default: we(() => [
          le.value || S.timePicker || S.timePickerInline ? (w(), W("div", {
            key: 0,
            ref_key: "overlayRef",
            ref: m,
            role: S.timePickerInline ? void 0 : "dialog",
            class: De({
              dp__overlay: !S.timePickerInline,
              "dp--overlay-absolute": !a.timePicker && !S.timePickerInline,
              "dp--overlay-relative": a.timePicker
            }),
            style: lt(S.timePicker ? { height: `${s(R).modeHeight}px` } : void 0),
            "aria-label": s(P)?.timePicker,
            tabindex: S.timePickerInline ? void 0 : 0
          }, [
            he("div", {
              class: De(
                S.timePickerInline ? "dp__time_picker_inline_container" : "dp__overlay_container dp__container_flex dp__time_picker_overlay_container"
              ),
              style: { display: "flex" }
            }, [
              S.$slots["time-picker-overlay"] ? ie(S.$slots, "time-picker-overlay", {
                key: 0,
                hours: e.hours,
                minutes: e.minutes,
                seconds: e.seconds,
                setHours: pe,
                setMinutes: p,
                setSeconds: Y
              }) : Q("", !0),
              S.$slots["time-picker-overlay"] ? Q("", !0) : (w(), W("div", {
                key: 1,
                class: De(S.timePickerInline ? "dp__flex" : "dp__overlay_row dp__flex_row")
              }, [
                (w(!0), W(ke, null, Ce($.value, (k, se) => ua((w(), Te(Pr, He({ key: se }, { ref_for: !0 }, {
                  ...S.$props,
                  order: se,
                  hours: k.hours,
                  minutes: k.minutes,
                  seconds: k.seconds,
                  closeTimePickerBtn: M.value,
                  disabledTimesConfig: e.disabledTimesConfig,
                  disabled: se === 0 ? s(h).fixedStart : s(h).fixedEnd
                }, {
                  ref_for: !0,
                  ref_key: "timeInputRefs",
                  ref: A,
                  "validate-time": (u, re) => e.validateTime(u, ce(re, se, u)),
                  "onUpdate:hours": (u) => pe(ce(u, se, "hours")),
                  "onUpdate:minutes": (u) => p(ce(u, se, "minutes")),
                  "onUpdate:seconds": (u) => Y(ce(u, se, "seconds")),
                  onMounted: te,
                  onOverlayClosed: y,
                  onOverlayOpened: V,
                  onAmPmChange: q[2] || (q[2] = (u) => S.$emit("am-pm-change", u))
                }), Ge({ _: 2 }, [
                  Ce(s(J), (u, re) => ({
                    name: u,
                    fn: we((G) => [
                      ie(S.$slots, u, He({ ref_for: !0 }, G))
                    ])
                  }))
                ]), 1040, ["validate-time", "onUpdate:hours", "onUpdate:minutes", "onUpdate:seconds"])), [
                  [ia, se === 0 ? !0 : L.value]
                ])), 128))
              ], 2)),
              !S.timePicker && !S.timePickerInline ? ua((w(), W("button", {
                key: 2,
                ref_key: "closeTimePickerBtn",
                ref: M,
                type: "button",
                class: De({ ...O.value, "dp--hidden-el": z.value }),
                "aria-label": s(P)?.closeTimePicker,
                tabindex: "0",
                onKeydown: q[3] || (q[3] = (k) => s(qe)(k, () => ee(!1))),
                onClick: q[4] || (q[4] = (k) => ee(!1))
              }, [
                S.$slots["calendar-icon"] ? ie(S.$slots, "calendar-icon", { key: 0 }) : Q("", !0),
                S.$slots["calendar-icon"] ? Q("", !0) : (w(), Te(s(jt), { key: 1 }))
              ], 42, Br)), [
                [ia, !s(_)(S.hideNavigation, "time")]
              ]) : Q("", !0)
            ], 2)
          ], 14, Or)) : Q("", !0)
        ]),
        _: 3
      }, 8, ["name", "css"])
    ], 8, Rr));
  }
}), Gn = (e, t, l, n) => {
  const { defaultedRange: a } = Oe(e), f = (m, z) => Array.isArray(t[m]) ? t[m][z] : t[m], i = (m) => e.enableSeconds ? Array.isArray(t.seconds) ? t.seconds[m] : t.seconds : 0, g = (m, z) => m ? z !== void 0 ? Mt(m, f("hours", z), f("minutes", z), i(z)) : Mt(m, t.hours, t.minutes, i()) : wn(H(), i(z)), d = (m, z) => {
    t[m] = z;
  }, P = j(() => e.modelAuto && a.value.enabled ? Array.isArray(l.value) ? l.value.length > 1 : !1 : a.value.enabled), v = (m, z) => {
    const L = Object.fromEntries(
      Object.keys(t).map((le) => le === m ? [le, z] : [le, t[le]].slice())
    );
    if (P.value && !a.value.disableTimeRangeValidation) {
      const le = ($) => l.value ? Mt(
        l.value[$],
        L.hours[$],
        L.minutes[$],
        L.seconds[$]
      ) : null, U = ($) => Dn(l.value[$], 0);
      return !($e(le(0), le(1)) && (_t(le(0), U(1)) || Ft(le(1), U(0))));
    }
    return !0;
  }, R = (m, z) => {
    v(m, z) && (d(m, z), n && n());
  }, h = (m) => {
    R("hours", m);
  }, T = (m) => {
    R("minutes", m);
  }, F = (m) => {
    R("seconds", m);
  }, _ = (m, z, L, le) => {
    z && h(m), !z && !L && T(m), L && F(m), l.value && le(l.value);
  }, C = (m) => {
    if (m) {
      const z = Array.isArray(m), L = z ? [+m[0].hours, +m[1].hours] : +m.hours, le = z ? [+m[0].minutes, +m[1].minutes] : +m.minutes, U = z ? [+m[0].seconds, +m[1].seconds] : +m.seconds;
      d("hours", L), d("minutes", le), e.enableSeconds && d("seconds", U);
    }
  }, M = (m, z) => {
    const L = {
      hours: Array.isArray(t.hours) ? t.hours[m] : t.hours,
      disabledArr: []
    };
    return (z || z === 0) && (L.hours = z), Array.isArray(e.disabledTimes) && (L.disabledArr = a.value.enabled && Array.isArray(e.disabledTimes[m]) ? e.disabledTimes[m] : e.disabledTimes), L;
  }, A = j(() => (m, z) => {
    if (Array.isArray(e.disabledTimes)) {
      const { disabledArr: L, hours: le } = M(m, z), U = L.filter(($) => +$.hours === le);
      return U[0]?.minutes === "*" ? { hours: [le], minutes: void 0, seconds: void 0 } : {
        hours: [],
        minutes: U?.map(($) => +$.minutes) ?? [],
        seconds: U?.map(($) => $.seconds ? +$.seconds : void 0) ?? []
      };
    }
    return { hours: [], minutes: [], seconds: [] };
  });
  return {
    setTime: d,
    updateHours: h,
    updateMinutes: T,
    updateSeconds: F,
    getSetDateTime: g,
    updateTimeValues: _,
    getSecondsValue: i,
    assignStartTime: C,
    validateTime: v,
    disabledTimesConfig: A
  };
}, _r = (e, t) => {
  const l = () => {
    e.isTextInputDate && z();
  }, { modelValue: n, time: a } = na(e, t, l), { defaultedStartTime: f, defaultedRange: i, defaultedTz: g } = Oe(e), { updateTimeValues: d, getSetDateTime: P, setTime: v, assignStartTime: R, disabledTimesConfig: h, validateTime: T } = Gn(e, a, n, F);
  function F() {
    t("update-flow-step");
  }
  const _ = (U) => {
    const { hours: $, minutes: ee, seconds: O } = U;
    return { hours: +$, minutes: +ee, seconds: O ? +O : 0 };
  }, C = () => {
    if (e.startTime) {
      if (Array.isArray(e.startTime)) {
        const $ = _(e.startTime[0]), ee = _(e.startTime[1]);
        return [Se(H(), $), Se(H(), ee)];
      }
      const U = _(e.startTime);
      return Se(H(), U);
    }
    return i.value.enabled ? [null, null] : null;
  }, M = () => {
    if (i.value.enabled) {
      const [U, $] = C();
      n.value = [
        Ze(P(U, 0), g.value.timezone),
        Ze(P($, 1), g.value.timezone)
      ];
    } else
      n.value = Ze(P(C()), g.value.timezone);
  }, A = (U) => Array.isArray(U) ? [Bt(H(U[0])), Bt(H(U[1]))] : [Bt(U ?? H())], m = (U, $, ee) => {
    v("hours", U), v("minutes", $), v("seconds", e.enableSeconds ? ee : 0);
  }, z = () => {
    const [U, $] = A(n.value);
    return i.value.enabled ? m(
      [U.hours, $.hours],
      [U.minutes, $.minutes],
      [U.seconds, $.seconds]
    ) : m(U.hours, U.minutes, U.seconds);
  };
  Ue(() => {
    if (!e.shadow)
      return R(f.value), n.value ? z() : M();
  });
  const L = () => {
    Array.isArray(n.value) ? n.value = n.value.map((U, $) => U && P(U, $)) : n.value = P(n.value), t("time-update");
  };
  return {
    modelValue: n,
    time: a,
    disabledTimesConfig: h,
    updateTime: (U, $ = !0, ee = !1) => {
      d(U, $, ee, L);
    },
    validateTime: T
  };
}, Yr = /* @__PURE__ */ We({
  compatConfig: {
    MODE: 3
  },
  __name: "TimePickerSolo",
  props: {
    ...dt
  },
  emits: [
    "update:internal-model-value",
    "time-update",
    "am-pm-change",
    "mount",
    "reset-flow",
    "update-flow-step",
    "overlay-toggle"
  ],
  setup(e, { expose: t, emit: l }) {
    const n = l, a = e, f = Yt(), i = et(f, "timePicker"), g = Z(null), { time: d, modelValue: P, disabledTimesConfig: v, updateTime: R, validateTime: h } = _r(a, n);
    return Ue(() => {
      a.shadow || n("mount", null);
    }), t({ getSidebarProps: () => ({
      modelValue: P,
      time: d,
      updateTime: R
    }), toggleTimePicker: (_, C = !1, M = "") => {
      g.value?.toggleTimePicker(_, C, M);
    } }), (_, C) => (w(), Te(ma, {
      "multi-calendars": 0,
      stretch: "",
      "is-mobile": _.isMobile
    }, {
      default: we(() => [
        tt(Kn, He({
          ref_key: "tpRef",
          ref: g
        }, _.$props, {
          hours: s(d).hours,
          minutes: s(d).minutes,
          seconds: s(d).seconds,
          "internal-model-value": _.internalModelValue,
          "disabled-times-config": s(v),
          "validate-time": s(h),
          "onUpdate:hours": C[0] || (C[0] = (M) => s(R)(M)),
          "onUpdate:minutes": C[1] || (C[1] = (M) => s(R)(M, !1)),
          "onUpdate:seconds": C[2] || (C[2] = (M) => s(R)(M, !1, !0)),
          onAmPmChange: C[3] || (C[3] = (M) => _.$emit("am-pm-change", M)),
          onResetFlow: C[4] || (C[4] = (M) => _.$emit("reset-flow")),
          onOverlayClosed: C[5] || (C[5] = (M) => _.$emit("overlay-toggle", { open: !1, overlay: M })),
          onOverlayOpened: C[6] || (C[6] = (M) => _.$emit("overlay-toggle", { open: !0, overlay: M }))
        }), Ge({ _: 2 }, [
          Ce(s(i), (M, A) => ({
            name: M,
            fn: we((m) => [
              ie(_.$slots, M, ze(Je(m)))
            ])
          }))
        ]), 1040, ["hours", "minutes", "seconds", "internal-model-value", "disabled-times-config", "validate-time"])
      ]),
      _: 3
    }, 8, ["is-mobile"]));
  }
}), Ir = { class: "dp--header-wrap" }, Er = {
  key: 0,
  class: "dp__month_year_wrap"
}, Nr = { key: 0 }, Lr = { class: "dp__month_year_wrap" }, Fr = ["data-dp-element", "aria-label", "data-test-id", "onClick", "onKeydown"], zr = /* @__PURE__ */ We({
  compatConfig: {
    MODE: 3
  },
  __name: "DpHeader",
  props: {
    month: { type: Number, default: 0 },
    year: { type: Number, default: 0 },
    instance: { type: Number, default: 0 },
    years: { type: Array, default: () => [] },
    months: { type: Array, default: () => [] },
    ...dt
  },
  emits: ["update-month-year", "mount", "reset-flow", "overlay-closed", "overlay-opened"],
  setup(e, { expose: t, emit: l }) {
    const n = l, a = e, {
      defaultedTransitions: f,
      defaultedAriaLabels: i,
      defaultedMultiCalendars: g,
      defaultedFilters: d,
      defaultedConfig: P,
      defaultedHighlight: v,
      propDates: R,
      defaultedUI: h
    } = Oe(a), { transitionName: T, showTransition: F } = aa(f), { buildMatrix: _ } = At(), { handleMonthYearChange: C, isDisabled: M, updateMonthYear: A } = or(a, n), { showLeftIcon: m, showRightIcon: z } = ga(), L = Z(!1), le = Z(!1), U = Z(!1), $ = Z([null, null, null, null]);
    Ue(() => {
      n("mount");
    });
    const ee = (u) => ({
      get: () => a[u],
      set: (re) => {
        const G = u === ot.month ? ot.year : ot.month;
        n("update-month-year", { [u]: re, [G]: a[G] }), u === ot.month ? y(!0) : V(!0);
      }
    }), O = j(ee(ot.month)), J = j(ee(ot.year)), ce = j(() => (u) => ({
      month: a.month,
      year: a.year,
      items: u === ot.month ? a.months : a.years,
      instance: a.instance,
      updateMonthYear: A,
      toggle: u === ot.month ? y : V
    })), pe = j(() => {
      const u = a.months.find((re) => re.value === a.month);
      return u || { text: "", value: 0 };
    }), p = j(() => Ht(a.months, (u) => {
      const re = a.month === u.value, G = Zt(
        u.value,
        _n(a.year, R.value.minDate),
        Yn(a.year, R.value.maxDate)
      ) || d.value.months.includes(u.value), I = Fn(v.value, u.value, a.year);
      return { active: re, disabled: G, highlighted: I };
    })), Y = j(() => Ht(a.years, (u) => {
      const re = a.year === u.value, G = Zt(
        u.value,
        Wt(R.value.minDate),
        Wt(R.value.maxDate)
      ) || d.value.years.includes(u.value), I = xa(v.value, u.value);
      return { active: re, disabled: G, highlighted: I };
    })), te = (u, re, G) => {
      G !== void 0 ? u.value = G : u.value = !u.value, u.value ? (U.value = !0, n("overlay-opened", re)) : (U.value = !1, n("overlay-closed", re));
    }, y = (u = !1, re) => {
      S(u), te(L, je.month, re);
    }, V = (u = !1, re) => {
      S(u), te(le, je.year, re);
    }, S = (u) => {
      u || n("reset-flow");
    }, q = (u, re) => {
      a.arrowNavigation && ($.value[re] = Le(u), _($.value, "monthYear"));
    }, k = j(() => [
      {
        type: ot.month,
        index: 1,
        toggle: y,
        modelValue: O.value,
        updateModelValue: (u) => O.value = u,
        text: pe.value.text,
        showSelectionGrid: L.value,
        items: p.value,
        ariaLabel: i.value?.openMonthsOverlay,
        overlayLabel: i.value.monthPicker?.(!0) ?? void 0
      },
      {
        type: ot.year,
        index: 2,
        toggle: V,
        modelValue: J.value,
        updateModelValue: (u) => J.value = u,
        text: Ja(a.year, a.locale),
        showSelectionGrid: le.value,
        items: Y.value,
        ariaLabel: i.value?.openYearsOverlay,
        overlayLabel: i.value.yearPicker?.(!0) ?? void 0
      }
    ]), se = j(() => a.disableYearSelect ? [k.value[0]] : a.yearFirst ? [...k.value].reverse() : k.value);
    return t({
      toggleMonthPicker: y,
      toggleYearPicker: V,
      handleMonthYearChange: C
    }), (u, re) => (w(), W("div", Ir, [
      u.$slots["month-year"] ? (w(), W("div", Er, [
        ie(u.$slots, "month-year", ze(Je({
          month: e.month,
          year: e.year,
          months: e.months,
          years: e.years,
          updateMonthYear: s(A),
          handleMonthYearChange: s(C),
          instance: e.instance,
          isDisabled: s(M)
        })))
      ])) : (w(), W(ke, { key: 1 }, [
        u.$slots["top-extra"] ? (w(), W("div", Nr, [
          ie(u.$slots, "top-extra", { value: u.internalModelValue })
        ])) : Q("", !0),
        he("div", Lr, [
          s(m)(s(g), e.instance) && !u.vertical ? (w(), Te(Qt, {
            key: 0,
            "aria-label": s(i)?.prevMonth,
            disabled: s(M)(!1),
            class: De(s(h)?.navBtnPrev),
            "el-name": "action-prev",
            onActivate: re[0] || (re[0] = (G) => s(C)(!1, !0)),
            onSetRef: re[1] || (re[1] = (G) => q(G, 0))
          }, {
            default: we(() => [
              u.$slots["arrow-left"] ? ie(u.$slots, "arrow-left", { key: 0 }) : Q("", !0),
              u.$slots["arrow-left"] ? Q("", !0) : (w(), Te(s(Ua), { key: 1 }))
            ]),
            _: 3
          }, 8, ["aria-label", "disabled", "class"])) : Q("", !0),
          he("div", {
            class: De(["dp__month_year_wrap", {
              dp__year_disable_select: u.disableYearSelect
            }])
          }, [
            (w(!0), W(ke, null, Ce(se.value, (G, I) => (w(), W(ke, {
              key: G.type
            }, [
              he("button", {
                ref_for: !0,
                ref: (x) => q(x, I + 1),
                type: "button",
                "data-dp-element": `overlay-${G.type}`,
                class: De(["dp__btn dp__month_year_select", { "dp--hidden-el": U.value }]),
                "aria-label": `${G.text}-${G.ariaLabel}`,
                "data-test-id": `${G.type}-toggle-overlay-${e.instance}`,
                onClick: G.toggle,
                onKeydown: (x) => s(qe)(x, () => G.toggle(), !0)
              }, [
                u.$slots[G.type] ? ie(u.$slots, G.type, {
                  key: 0,
                  text: G.text,
                  value: a[G.type]
                }) : Q("", !0),
                u.$slots[G.type] ? Q("", !0) : (w(), W(ke, { key: 1 }, [
                  gt(Ke(G.text), 1)
                ], 64))
              ], 42, Fr),
              tt(Vt, {
                name: s(T)(G.showSelectionGrid),
                css: s(F)
              }, {
                default: we(() => [
                  G.showSelectionGrid ? (w(), Te(ta, {
                    key: 0,
                    items: G.items,
                    "arrow-navigation": u.arrowNavigation,
                    "hide-navigation": u.hideNavigation,
                    "is-last": u.autoApply && !s(P).keepActionRow,
                    "skip-button-ref": !1,
                    config: u.config,
                    type: G.type,
                    "header-refs": [],
                    "esc-close": u.escClose,
                    "menu-wrap-ref": u.menuWrapRef,
                    "text-input": u.textInput,
                    "aria-labels": u.ariaLabels,
                    "overlay-label": G.overlayLabel,
                    onSelected: G.updateModelValue,
                    onToggle: G.toggle
                  }, Ge({
                    "button-icon": we(() => [
                      u.$slots["calendar-icon"] ? ie(u.$slots, "calendar-icon", { key: 0 }) : Q("", !0),
                      u.$slots["calendar-icon"] ? Q("", !0) : (w(), Te(s(jt), { key: 1 }))
                    ]),
                    _: 2
                  }, [
                    u.$slots[`${G.type}-overlay-value`] ? {
                      name: "item",
                      fn: we(({ item: x }) => [
                        ie(u.$slots, `${G.type}-overlay-value`, {
                          text: x.text,
                          value: x.value
                        })
                      ]),
                      key: "0"
                    } : void 0,
                    u.$slots[`${G.type}-overlay`] ? {
                      name: "overlay",
                      fn: we(() => [
                        ie(u.$slots, `${G.type}-overlay`, He({ ref_for: !0 }, ce.value(G.type)))
                      ]),
                      key: "1"
                    } : void 0,
                    u.$slots[`${G.type}-overlay-header`] ? {
                      name: "header",
                      fn: we(() => [
                        ie(u.$slots, `${G.type}-overlay-header`, {
                          toggle: G.toggle
                        })
                      ]),
                      key: "2"
                    } : void 0
                  ]), 1032, ["items", "arrow-navigation", "hide-navigation", "is-last", "config", "type", "esc-close", "menu-wrap-ref", "text-input", "aria-labels", "overlay-label", "onSelected", "onToggle"])) : Q("", !0)
                ]),
                _: 2
              }, 1032, ["name", "css"])
            ], 64))), 128))
          ], 2),
          s(m)(s(g), e.instance) && u.vertical ? (w(), Te(Qt, {
            key: 1,
            "aria-label": s(i)?.prevMonth,
            "el-name": "action-prev",
            disabled: s(M)(!1),
            class: De(s(h)?.navBtnPrev),
            onActivate: re[2] || (re[2] = (G) => s(C)(!1, !0))
          }, {
            default: we(() => [
              u.$slots["arrow-up"] ? ie(u.$slots, "arrow-up", { key: 0 }) : Q("", !0),
              u.$slots["arrow-up"] ? Q("", !0) : (w(), Te(s(Ka), { key: 1 }))
            ]),
            _: 3
          }, 8, ["aria-label", "disabled", "class"])) : Q("", !0),
          s(z)(s(g), e.instance) ? (w(), Te(Qt, {
            key: 2,
            ref: "rightIcon",
            "el-name": "action-next",
            disabled: s(M)(!0),
            "aria-label": s(i)?.nextMonth,
            class: De(s(h)?.navBtnNext),
            onActivate: re[3] || (re[3] = (G) => s(C)(!0, !0)),
            onSetRef: re[4] || (re[4] = (G) => q(G, u.disableYearSelect ? 2 : 3))
          }, {
            default: we(() => [
              u.$slots[u.vertical ? "arrow-down" : "arrow-right"] ? ie(u.$slots, u.vertical ? "arrow-down" : "arrow-right", { key: 0 }) : Q("", !0),
              u.$slots[u.vertical ? "arrow-down" : "arrow-right"] ? Q("", !0) : (w(), Te(fa(u.vertical ? s(Ga) : s(Va)), { key: 1 }))
            ]),
            _: 3
          }, 8, ["disabled", "aria-label", "class"])) : Q("", !0)
        ])
      ], 64))
    ]));
  }
}), Hr = {
  class: "dp__calendar_header",
  role: "row"
}, Wr = {
  key: 0,
  class: "dp__calendar_header_item",
  role: "gridcell"
}, Ur = ["aria-label"], Vr = {
  key: 0,
  class: "dp__calendar_item dp__week_num",
  role: "gridcell"
}, jr = { class: "dp__cell_inner" }, Kr = ["id", "aria-selected", "aria-disabled", "aria-label", "tabindex", "data-test-id", "onClick", "onTouchend", "onKeydown", "onMouseenter", "onMouseleave", "onMousedown"], Gr = /* @__PURE__ */ We({
  compatConfig: {
    MODE: 3
  },
  __name: "DpCalendar",
  props: {
    mappedDates: { type: Array, default: () => [] },
    instance: { type: Number, default: 0 },
    month: { type: Number, default: 0 },
    year: { type: Number, default: 0 },
    ...dt
  },
  emits: [
    "select-date",
    "set-hover-date",
    "handle-scroll",
    "mount",
    "handle-swipe",
    "handle-space",
    "tooltip-open",
    "tooltip-close"
  ],
  setup(e, { expose: t, emit: l }) {
    const n = l, a = e, { buildMultiLevelMatrix: f } = At(), {
      defaultedTransitions: i,
      defaultedConfig: g,
      defaultedAriaLabels: d,
      defaultedMultiCalendars: P,
      defaultedWeekNumbers: v,
      defaultedMultiDates: R,
      defaultedUI: h
    } = Oe(a), T = Z(null), F = Z({
      bottom: "",
      left: "",
      transform: ""
    }), _ = Z([]), C = Z(null), M = Z(!0), A = Z(""), m = Z({ startX: 0, endX: 0, startY: 0, endY: 0 }), z = Z([]), L = Z({ left: "50%" }), le = Z(!1), U = j(() => a.calendar ? a.calendar(a.mappedDates) : a.mappedDates), $ = j(() => a.dayNames ? Array.isArray(a.dayNames) ? a.dayNames : a.dayNames(a.locale, +a.weekStart) : Tl(a.formatLocale, a.locale, +a.weekStart));
    Ue(() => {
      n("mount", { cmp: "calendar", refs: _ }), g.value.noSwipe || C.value && (C.value.addEventListener("touchstart", q, { passive: !1 }), C.value.addEventListener("touchend", k, { passive: !1 }), C.value.addEventListener("touchmove", se, { passive: !1 })), a.monthChangeOnScroll && C.value && C.value.addEventListener("wheel", G, { passive: !1 });
    }), Ut(() => {
      g.value.noSwipe || C.value && (C.value.removeEventListener("touchstart", q), C.value.removeEventListener("touchend", k), C.value.removeEventListener("touchmove", se)), a.monthChangeOnScroll && C.value && C.value.removeEventListener("wheel", G);
    });
    const ee = (B) => B ? a.vertical ? "vNext" : "next" : a.vertical ? "vPrevious" : "previous", O = (B, be) => {
      if (a.transitions) {
        const Ae = Fe(pt(H(), a.month, a.year));
        A.value = Ee(Fe(pt(H(), B, be)), Ae) ? i.value[ee(!0)] : i.value[ee(!1)], M.value = !1, at(() => {
          M.value = !0;
        });
      }
    }, J = j(
      () => ({
        ...h.value.calendar ?? {}
      })
    ), ce = j(() => (B) => {
      const be = Pl(B);
      return {
        dp__marker_dot: be.type === "dot",
        dp__marker_line: be.type === "line"
      };
    }), pe = j(() => (B) => $e(B, T.value)), p = j(() => ({
      dp__calendar: !0,
      dp__calendar_next: P.value.count > 0 && a.instance !== 0
    })), Y = j(() => (B) => a.hideOffsetDates ? B.current : !0), te = async (B, be) => {
      const { width: Ae, height: ne } = B.getBoundingClientRect();
      T.value = be.value;
      let r = { left: `${Ae / 2}px` }, E = -50;
      if (await at(), z.value[0]) {
        const { left: K, width: oe } = z.value[0].getBoundingClientRect();
        K < 0 && (r = { left: "0" }, E = 0, L.value.left = `${Ae / 2}px`), window.innerWidth < K + oe && (r = { right: "0" }, E = 0, L.value.left = `${oe - Ae / 2}px`);
      }
      F.value = {
        bottom: `${ne}px`,
        ...r,
        transform: `translateX(${E}%)`
      };
    }, y = async (B, be, Ae) => {
      const ne = Le(_.value[be][Ae]);
      ne && (B.marker?.customPosition && B.marker?.tooltip?.length ? F.value = B.marker.customPosition(ne) : await te(ne, B), n("tooltip-open", B.marker));
    }, V = async (B, be, Ae) => {
      if (le.value && R.value.enabled && R.value.dragSelect)
        return n("select-date", B);
      if (n("set-hover-date", B), B.marker?.tooltip?.length) {
        if (a.hideOffsetDates && !B.current) return;
        await y(B, be, Ae);
      }
    }, S = (B) => {
      T.value && (T.value = null, F.value = JSON.parse(JSON.stringify({ bottom: "", left: "", transform: "" })), n("tooltip-close", B.marker));
    }, q = (B) => {
      m.value.startX = B.changedTouches[0].screenX, m.value.startY = B.changedTouches[0].screenY;
    }, k = (B) => {
      m.value.endX = B.changedTouches[0].screenX, m.value.endY = B.changedTouches[0].screenY, u();
    }, se = (B) => {
      a.vertical && !a.inline && B.preventDefault();
    }, u = () => {
      const B = a.vertical ? "Y" : "X";
      Math.abs(m.value[`start${B}`] - m.value[`end${B}`]) > 10 && n("handle-swipe", m.value[`start${B}`] > m.value[`end${B}`] ? "right" : "left");
    }, re = (B, be, Ae) => {
      B && (Array.isArray(_.value[be]) ? _.value[be][Ae] = B : _.value[be] = [B]), a.arrowNavigation && f(_.value, "calendar");
    }, G = (B) => {
      a.monthChangeOnScroll && (B.preventDefault(), n("handle-scroll", B));
    }, I = (B) => v.value.type === "local" ? pl(B.value, { weekStartsOn: +a.weekStart }) : v.value.type === "iso" ? gl(B.value) : typeof v.value.type == "function" ? v.value.type(B.value) : "", x = (B) => {
      const be = B[0];
      return v.value.hideOnOffsetDates ? B.some((Ae) => Ae.current) ? I(be) : "" : I(be);
    }, c = (B, be, Ae = !0) => {
      !Ae && _l() || (!R.value.enabled || g.value.allowPreventDefault) && (Dt(B, g.value), n("select-date", be));
    }, o = (B) => {
      Dt(B, g.value);
    }, X = (B) => {
      R.value.enabled && R.value.dragSelect ? (le.value = !0, n("select-date", B)) : R.value.enabled && n("select-date", B);
    };
    return t({ triggerTransition: O }), (B, be) => (w(), W("div", {
      class: De(p.value)
    }, [
      he("div", {
        ref_key: "calendarWrapRef",
        ref: C,
        class: De(J.value),
        role: "grid"
      }, [
        he("div", Hr, [
          B.weekNumbers ? (w(), W("div", Wr, Ke(B.weekNumName), 1)) : Q("", !0),
          (w(!0), W(ke, null, Ce($.value, (Ae, ne) => (w(), W("div", {
            key: ne,
            class: "dp__calendar_header_item",
            role: "gridcell",
            "data-test-id": "calendar-header",
            "aria-label": s(d)?.weekDay?.(ne)
          }, [
            B.$slots["calendar-header"] ? ie(B.$slots, "calendar-header", {
              key: 0,
              day: Ae,
              index: ne
            }) : Q("", !0),
            B.$slots["calendar-header"] ? Q("", !0) : (w(), W(ke, { key: 1 }, [
              gt(Ke(Ae), 1)
            ], 64))
          ], 8, Ur))), 128))
        ]),
        be[2] || (be[2] = he("div", { class: "dp__calendar_header_separator" }, null, -1)),
        tt(Vt, {
          name: A.value,
          css: !!B.transitions
        }, {
          default: we(() => [
            M.value ? (w(), W("div", {
              key: 0,
              class: "dp__calendar",
              role: "rowgroup",
              onMouseleave: be[1] || (be[1] = (Ae) => le.value = !1)
            }, [
              (w(!0), W(ke, null, Ce(U.value, (Ae, ne) => (w(), W("div", {
                key: ne,
                class: "dp__calendar_row",
                role: "row"
              }, [
                B.weekNumbers ? (w(), W("div", Vr, [
                  he("div", jr, Ke(x(Ae.days)), 1)
                ])) : Q("", !0),
                (w(!0), W(ke, null, Ce(Ae.days, (r, E) => (w(), W("div", {
                  id: s(Ha)(r.value),
                  ref_for: !0,
                  ref: (K) => re(K, ne, E),
                  key: E + ne,
                  role: "gridcell",
                  class: "dp__calendar_item",
                  "aria-selected": (r.classData.dp__active_date || r.classData.dp__range_start || r.classData.dp__range_end) ?? void 0,
                  "aria-disabled": r.classData.dp__cell_disabled || void 0,
                  "aria-label": s(d)?.day?.(r),
                  tabindex: !r.current && B.hideOffsetDates ? void 0 : 0,
                  "data-test-id": s(Ha)(r.value),
                  onClick: Xt((K) => c(K, r), ["prevent"]),
                  onTouchend: (K) => c(K, r, !1),
                  onKeydown: (K) => s(qe)(K, () => B.$emit("select-date", r)),
                  onMouseenter: (K) => V(r, ne, E),
                  onMouseleave: (K) => S(r),
                  onMousedown: (K) => X(r),
                  onMouseup: be[0] || (be[0] = (K) => le.value = !1)
                }, [
                  he("div", {
                    class: De(["dp__cell_inner", r.classData])
                  }, [
                    B.$slots.day && Y.value(r) ? ie(B.$slots, "day", {
                      key: 0,
                      day: +r.text,
                      date: r.value
                    }) : Q("", !0),
                    B.$slots.day ? Q("", !0) : (w(), W(ke, { key: 1 }, [
                      gt(Ke(r.text), 1)
                    ], 64)),
                    r.marker && Y.value(r) ? (w(), W(ke, { key: 2 }, [
                      B.$slots.marker ? ie(B.$slots, "marker", {
                        key: 0,
                        marker: r.marker,
                        day: +r.text,
                        date: r.value
                      }) : (w(), W("div", {
                        key: 1,
                        class: De(ce.value(r.marker)),
                        style: lt(r.marker.color ? { backgroundColor: r.marker.color } : {})
                      }, null, 6))
                    ], 64)) : Q("", !0),
                    pe.value(r.value) ? (w(), W("div", {
                      key: 3,
                      ref_for: !0,
                      ref_key: "activeTooltip",
                      ref: z,
                      class: "dp__marker_tooltip",
                      style: lt(F.value)
                    }, [
                      r.marker?.tooltip ? (w(), W("div", {
                        key: 0,
                        class: "dp__tooltip_content",
                        onClick: o
                      }, [
                        (w(!0), W(ke, null, Ce(r.marker.tooltip, (K, oe) => (w(), W("div", {
                          key: oe,
                          class: "dp__tooltip_text"
                        }, [
                          B.$slots["marker-tooltip"] ? ie(B.$slots, "marker-tooltip", {
                            key: 0,
                            tooltip: K,
                            day: r.value
                          }) : Q("", !0),
                          B.$slots["marker-tooltip"] ? Q("", !0) : (w(), W(ke, { key: 1 }, [
                            he("div", {
                              class: "dp__tooltip_mark",
                              style: lt(K.color ? { backgroundColor: K.color } : {})
                            }, null, 4),
                            he("div", null, Ke(K.text), 1)
                          ], 64))
                        ]))), 128)),
                        he("div", {
                          class: "dp__arrow_bottom_tp",
                          style: lt(L.value)
                        }, null, 4)
                      ])) : Q("", !0)
                    ], 4)) : Q("", !0)
                  ], 2)
                ], 40, Kr))), 128))
              ]))), 128))
            ], 32)) : Q("", !0)
          ]),
          _: 3
        }, 8, ["name", "css"])
      ], 2)
    ], 2));
  }
}), yn = (e) => Array.isArray(e), Qr = (e, t, l, n) => {
  const a = Z([]), f = Z(/* @__PURE__ */ new Date()), i = Z(), g = () => k(e.isTextInputDate), { modelValue: d, calendars: P, time: v, today: R } = na(e, t, g), {
    defaultedMultiCalendars: h,
    defaultedStartTime: T,
    defaultedRange: F,
    defaultedConfig: _,
    defaultedTz: C,
    propDates: M,
    defaultedMultiDates: A
  } = Oe(e), { validateMonthYearInRange: m, isDisabled: z, isDateRangeAllowed: L, checkMinMaxRange: le } = Tt(e), { updateTimeValues: U, getSetDateTime: $, setTime: ee, assignStartTime: O, validateTime: J, disabledTimesConfig: ce } = Gn(e, v, d, n), pe = j(
    () => (b) => P.value[b] ? P.value[b].month : 0
  ), p = j(
    () => (b) => P.value[b] ? P.value[b].year : 0
  ), Y = (b) => !_.value.keepViewOnOffsetClick || b ? !0 : !i.value, te = (b, ae, ve, N = !1) => {
    Y(N) && (P.value[b] || (P.value[b] = { month: 0, year: 0 }), P.value[b].month = cn(ae) ? P.value[b]?.month : ae, P.value[b].year = cn(ve) ? P.value[b]?.year : ve);
  }, y = () => {
    e.autoApply && t("select-date");
  }, V = () => {
    T.value && O(T.value);
  };
  Ue(() => {
    e.shadow || (d.value || (be(), V()), k(!0), e.focusStartDate && e.startDate && be());
  });
  const S = j(() => e.flow?.length && !e.partialFlow ? e.flowStep === e.flow.length : !0), q = () => {
    e.autoApply && S.value && t("auto-apply", e.partialFlow ? e.flowStep !== e.flow.length : !1);
  }, k = (b = !1) => {
    if (d.value)
      return Array.isArray(d.value) ? (a.value = d.value, c(b)) : re(d.value, b);
    if (h.value.count && b && !e.startDate)
      return u(H(), b);
  }, se = () => Array.isArray(d.value) && F.value.enabled ? Me(d.value[0]) === Me(d.value[1] ?? d.value[0]) : !1, u = (b = /* @__PURE__ */ new Date(), ae = !1) => {
    if ((!h.value.count || !h.value.static || ae) && te(0, Me(b), ye(b)), h.value.count && (!d.value || se() || !h.value.solo) && (!h.value.solo || ae))
      for (let ve = 1; ve < h.value.count; ve++) {
        const N = Se(H(), { month: pe.value(ve - 1), year: p.value(ve - 1) }), ue = Tn(N, { months: 1 });
        P.value[ve] = { month: Me(ue), year: ye(ue) };
      }
  }, re = (b, ae) => {
    u(b), ee("hours", yt(b)), ee("minutes", $t(b)), ee("seconds", zt(b)), h.value.count && ae && B();
  }, G = (b) => {
    if (h.value.count) {
      if (h.value.solo) return 0;
      const ae = Me(b[0]), ve = Me(b[1]);
      return Math.abs(ve - ae) < h.value.count ? 0 : 1;
    }
    return 1;
  }, I = (b, ae) => {
    b[1] && F.value.showLastInRange ? u(b[G(b)], ae) : u(b[0], ae);
    const ve = (N, ue) => [
      N(b[0]),
      b[1] ? N(b[1]) : v[ue][1]
    ];
    ee("hours", ve(yt, "hours")), ee("minutes", ve($t, "minutes")), ee("seconds", ve(zt, "seconds"));
  }, x = (b, ae) => {
    if ((F.value.enabled || e.weekPicker) && !A.value.enabled)
      return I(b, ae);
    if (A.value.enabled && ae) {
      const ve = b[b.length - 1];
      return re(ve, ae);
    }
  }, c = (b) => {
    const ae = d.value;
    x(ae, b), h.value.count && h.value.solo && B();
  }, o = (b, ae) => {
    const ve = Se(H(), { month: pe.value(ae), year: p.value(ae) }), N = b < 0 ? Ct(ve, 1) : Jt(ve, 1);
    m(Me(N), ye(N), b < 0, e.preventMinMaxNavigation) && (te(ae, Me(N), ye(N)), t("update-month-year", { instance: ae, month: Me(N), year: ye(N) }), h.value.count && !h.value.solo && X(ae), l());
  }, X = (b) => {
    for (let ae = b - 1; ae >= 0; ae--) {
      const ve = Jt(Se(H(), { month: pe.value(ae + 1), year: p.value(ae + 1) }), 1);
      te(ae, Me(ve), ye(ve));
    }
    for (let ae = b + 1; ae <= h.value.count - 1; ae++) {
      const ve = Ct(Se(H(), { month: pe.value(ae - 1), year: p.value(ae - 1) }), 1);
      te(ae, Me(ve), ye(ve));
    }
  }, B = () => {
    if (Array.isArray(d.value) && d.value.length === 2) {
      const b = H(
        H(d.value[1] ? d.value[1] : Ct(d.value[0], 1))
      ), [ae, ve] = [Me(d.value[0]), ye(d.value[0])], [N, ue] = [Me(d.value[1]), ye(d.value[1])];
      (ae !== N || ae === N && ve !== ue) && h.value.solo && te(1, Me(b), ye(b));
    } else d.value && !Array.isArray(d.value) && (te(0, Me(d.value), ye(d.value)), u(H()));
  }, be = () => {
    e.startDate && (te(0, Me(H(e.startDate)), ye(H(e.startDate))), h.value.count && X(0));
  }, Ae = (b, ae) => {
    if (e.monthChangeOnScroll) {
      const ve = (/* @__PURE__ */ new Date()).getTime() - f.value.getTime(), N = Math.abs(b.deltaY);
      let ue = 500;
      N > 1 && (ue = 100), N > 100 && (ue = 0), ve > ue && (f.value = /* @__PURE__ */ new Date(), o(e.monthChangeOnScroll !== "inverse" ? -b.deltaY : b.deltaY, ae));
    }
  }, ne = (b, ae, ve = !1) => {
    e.monthChangeOnArrows && e.vertical === ve && r(b, ae);
  }, r = (b, ae) => {
    o(b === "right" ? -1 : 1, ae);
  }, E = (b) => {
    if (M.value.markers)
      return ca(b.value, M.value.markers);
  }, K = (b, ae) => {
    switch (e.sixWeeks === !0 ? "append" : e.sixWeeks) {
      case "prepend":
        return [!0, !1];
      case "center":
        return [b == 0, !0];
      case "fair":
        return [b == 0 || ae > b, !0];
      case "append":
        return [!1, !1];
      default:
        return [!1, !1];
    }
  }, oe = (b, ae, ve, N) => {
    if (e.sixWeeks && b.length < 6) {
      const ue = 6 - b.length, me = (ae.getDay() + 7 - N) % 7, ct = 6 - (ve.getDay() + 7 - N) % 7, [Pt, $a] = K(me, ct);
      for (let Rt = 1; Rt <= ue; Rt++)
        if ($a ? !!(Rt % 2) == Pt : Pt) {
          const ra = b[0].days[0], Aa = ge(kt(ra.value, -7), Me(ae));
          b.unshift({ days: Aa });
        } else {
          const ra = b[b.length - 1], Aa = ra.days[ra.days.length - 1], Xn = ge(kt(Aa.value, 1), Me(ae));
          b.push({ days: Xn });
        }
    }
    return b;
  }, ge = (b, ae) => {
    const ve = H(b), N = [];
    for (let ue = 0; ue < 7; ue++) {
      const me = kt(ve, ue), vt = Me(me) !== ae;
      N.push({
        text: e.hideOffsetDates && vt ? "" : me.getDate(),
        value: me,
        current: !vt,
        classData: {}
      });
    }
    return N;
  }, _e = (b, ae) => {
    const ve = [], N = new Date(ae, b), ue = new Date(ae, b + 1, 0), me = e.weekStart, vt = Wa(N, { weekStartsOn: me }), ct = (Pt) => {
      const $a = ge(Pt, b);
      if (ve.push({ days: $a }), !ve[ve.length - 1].days.some(
        (Rt) => $e(Fe(Rt.value), Fe(ue))
      )) {
        const Rt = kt(Pt, 7);
        ct(Rt);
      }
    };
    return ct(vt), oe(ve, N, ue, me);
  }, Ye = (b) => {
    const ae = Mt(H(b.value), v.hours, v.minutes, xe());
    t("date-update", ae), A.value.enabled ? en(ae, d, A.value.limit) : d.value = ae, n(), at().then(() => {
      q();
    });
  }, nt = (b) => F.value.noDisabledRange ? In(a.value[0], b).some((ve) => z(ve)) : !1, St = () => {
    a.value = d.value ? d.value.slice() : [], a.value.length === 2 && !(F.value.fixedStart || F.value.fixedEnd) && (a.value = []);
  }, D = (b, ae) => {
    const ve = [
      H(b.value),
      kt(H(b.value), +F.value.autoRange)
    ];
    L(ve) ? (ae && de(b.value), a.value = ve) : t("invalid-date", b.value);
  }, de = (b) => {
    const ae = Me(H(b)), ve = ye(H(b));
    if (te(0, ae, ve), h.value.count > 0)
      for (let N = 1; N < h.value.count; N++) {
        const ue = El(
          Se(H(b), { year: p.value(N - 1), month: pe.value(N - 1) })
        );
        te(N, ue.month, ue.year);
      }
  }, fe = (b) => {
    if (nt(b.value) || !le(b.value, d.value, F.value.fixedStart ? 0 : 1))
      return t("invalid-date", b.value);
    a.value = Vn(H(b.value), d, t, F);
  }, ht = (b, ae) => {
    if (St(), F.value.autoRange) return D(b, ae);
    if (F.value.fixedStart || F.value.fixedEnd) return fe(b);
    a.value[0] ? le(H(b.value), d.value) && !nt(b.value) ? Be(H(b.value), H(a.value[0])) ? (a.value.unshift(H(b.value)), t("range-end", a.value[0])) : (a.value[1] = H(b.value), t("range-end", a.value[1])) : (e.autoApply && t("auto-apply-invalid", b.value), t("invalid-date", b.value)) : (a.value[0] = H(b.value), t("range-start", a.value[0]));
  }, xe = (b = !0) => e.enableSeconds ? Array.isArray(v.seconds) ? b ? v.seconds[0] : v.seconds[1] : v.seconds : 0, Xe = (b) => {
    a.value[b] = Mt(
      a.value[b],
      v.hours[b],
      v.minutes[b],
      xe(b !== 1)
    );
  }, ya = () => {
    a.value[0] && a.value[1] && +a.value?.[0] > +a.value?.[1] && (a.value.reverse(), t("range-start", a.value[0]), t("range-end", a.value[1]));
  }, ha = () => {
    a.value.length && (a.value[0] && !a.value[1] ? Xe(0) : (Xe(0), Xe(1), n()), ya(), d.value = a.value.slice(), pa(a.value, t, e.autoApply, e.modelAuto));
  }, la = (b, ae = !1) => {
    if (z(b.value) || !b.current && e.hideOffsetDates) return t("invalid-date", b.value);
    if (i.value = JSON.parse(JSON.stringify(b)), !F.value.enabled) return Ye(b);
    yn(v.hours) && yn(v.minutes) && !A.value.enabled && (ht(b, ae), ha());
  }, ba = (b, ae) => {
    te(b, ae.month, ae.year, !0), h.value.count && !h.value.solo && X(b), t("update-month-year", { instance: b, month: ae.month, year: ae.year }), l(h.value.solo ? b : void 0);
    const ve = e.flow?.length ? e.flow[e.flowStep] : void 0;
    !ae.fromNav && (ve === je.month || ve === je.year) && n();
  }, ka = (b, ae) => {
    Un({
      value: b,
      modelValue: d,
      range: F.value.enabled,
      timezone: ae ? void 0 : C.value.timezone
    }), y(), e.multiCalendars && at().then(() => k(!0));
  }, wa = () => {
    const b = Qa(H(), C.value);
    !F.value.enabled && !A.value.enabled ? d.value = b : d.value && Array.isArray(d.value) && d.value[0] ? A.value.enabled ? d.value = [...d.value, b] : d.value = Be(b, d.value[0]) ? [b, d.value[0]] : [d.value[0], b] : d.value = [b], y();
  }, Da = () => {
    if (Array.isArray(d.value))
      if (A.value.enabled) {
        const b = Ma();
        d.value[d.value.length - 1] = $(b);
      } else
        d.value = d.value.map((b, ae) => b && $(b, ae));
    else
      d.value = $(d.value);
    t("time-update");
  }, Ma = () => Array.isArray(d.value) && d.value.length ? d.value[d.value.length - 1] : null;
  return {
    calendars: P,
    modelValue: d,
    month: pe,
    year: p,
    time: v,
    disabledTimesConfig: ce,
    today: R,
    validateTime: J,
    getCalendarDays: _e,
    getMarker: E,
    handleScroll: Ae,
    handleSwipe: r,
    handleArrow: ne,
    selectDate: la,
    updateMonthYear: ba,
    presetDate: ka,
    selectCurrentDate: wa,
    updateTime: (b, ae = !0, ve = !1) => {
      U(b, ae, ve, Da);
    },
    assignMonthAndYear: u,
    setStartTime: V
  };
}, qr = { key: 0 }, Xr = /* @__PURE__ */ We({
  __name: "DatePicker",
  props: {
    ...dt
  },
  emits: [
    "tooltip-open",
    "tooltip-close",
    "mount",
    "update:internal-model-value",
    "update-flow-step",
    "reset-flow",
    "auto-apply",
    "focus-menu",
    "select-date",
    "range-start",
    "range-end",
    "invalid-fixed-range",
    "time-update",
    "am-pm-change",
    "time-picker-open",
    "time-picker-close",
    "recalculate-position",
    "update-month-year",
    "auto-apply-invalid",
    "date-update",
    "invalid-date",
    "overlay-toggle"
  ],
  setup(e, { expose: t, emit: l }) {
    const n = l, a = e, {
      calendars: f,
      month: i,
      year: g,
      modelValue: d,
      time: P,
      disabledTimesConfig: v,
      today: R,
      validateTime: h,
      getCalendarDays: T,
      getMarker: F,
      handleArrow: _,
      handleScroll: C,
      handleSwipe: M,
      selectDate: A,
      updateMonthYear: m,
      presetDate: z,
      selectCurrentDate: L,
      updateTime: le,
      assignMonthAndYear: U,
      setStartTime: $
    } = Qr(a, n, se, u), ee = Yt(), { setHoverDate: O, getDayClassData: J, clearHoverDate: ce } = mo(d, a), { defaultedMultiCalendars: pe } = Oe(a), p = Z([]), Y = Z([]), te = Z(null), y = et(ee, "calendar"), V = et(ee, "monthYear"), S = et(ee, "timePicker"), q = (ne) => {
      a.shadow || n("mount", ne);
    };
    rt(
      f,
      () => {
        a.shadow || setTimeout(() => {
          n("recalculate-position");
        }, 0);
      },
      { deep: !0 }
    ), rt(
      pe,
      (ne, r) => {
        ne.count - r.count > 0 && U();
      },
      { deep: !0 }
    );
    const k = j(() => (ne) => T(i.value(ne), g.value(ne)).map((r) => ({
      ...r,
      days: r.days.map((E) => (E.marker = F(E), E.classData = J(E), E))
    })));
    function se(ne) {
      ne || ne === 0 ? Y.value[ne]?.triggerTransition(i.value(ne), g.value(ne)) : Y.value.forEach((r, E) => r.triggerTransition(i.value(E), g.value(E)));
    }
    function u() {
      n("update-flow-step");
    }
    const re = (ne, r = !1) => {
      A(ne, r), a.spaceConfirm && n("select-date");
    }, G = (ne, r, E = 0) => {
      p.value[E]?.toggleMonthPicker(ne, r);
    }, I = (ne, r, E = 0) => {
      p.value[E]?.toggleYearPicker(ne, r);
    }, x = (ne, r, E) => {
      te.value?.toggleTimePicker(ne, r, E);
    }, c = (ne, r) => {
      if (!a.range) {
        const E = d.value ? d.value : R, K = r ? new Date(r) : E, oe = ne ? Wa(K, { weekStartsOn: 1 }) : kn(K, { weekStartsOn: 1 });
        A({
          value: oe,
          current: Me(K) === i.value(0),
          text: "",
          classData: {}
        }), document.getElementById(Ha(oe))?.focus();
      }
    }, o = (ne) => {
      p.value[0]?.handleMonthYearChange(ne, !0);
    }, X = (ne) => {
      m(0, { month: i.value(0), year: g.value(0) + (ne ? 1 : -1), fromNav: !0 });
    }, B = (ne, r) => {
      ne === je.time && n(`time-picker-${r ? "open" : "close"}`), n("overlay-toggle", { open: r, overlay: ne });
    }, be = (ne) => {
      n("overlay-toggle", { open: !1, overlay: ne }), n("focus-menu");
    };
    return t({
      clearHoverDate: ce,
      presetDate: z,
      selectCurrentDate: L,
      toggleMonthPicker: G,
      toggleYearPicker: I,
      toggleTimePicker: x,
      handleArrow: _,
      updateMonthYear: m,
      getSidebarProps: () => ({
        modelValue: d,
        month: i,
        year: g,
        time: P,
        updateTime: le,
        updateMonthYear: m,
        selectDate: A,
        presetDate: z
      }),
      changeMonth: o,
      changeYear: X,
      selectWeekDate: c,
      setStartTime: $
    }), (ne, r) => (w(), W(ke, null, [
      tt(ma, {
        "multi-calendars": s(pe).count,
        collapse: ne.collapse,
        "is-mobile": ne.isMobile
      }, {
        default: we(({ instance: E, index: K }) => [
          ne.disableMonthYearSelect ? Q("", !0) : (w(), Te(zr, He({
            key: 0,
            ref: (oe) => {
              oe && (p.value[K] = oe);
            },
            months: s(Pn)(ne.formatLocale, ne.locale, ne.monthNameFormat),
            years: s(qa)(ne.yearRange, ne.locale, ne.reverseYears),
            month: s(i)(E),
            year: s(g)(E),
            instance: E
          }, ne.$props, {
            onMount: r[0] || (r[0] = (oe) => q(s(Ot).header)),
            onResetFlow: r[1] || (r[1] = (oe) => ne.$emit("reset-flow")),
            onUpdateMonthYear: (oe) => s(m)(E, oe),
            onOverlayClosed: be,
            onOverlayOpened: r[2] || (r[2] = (oe) => ne.$emit("overlay-toggle", { open: !0, overlay: oe }))
          }), Ge({ _: 2 }, [
            Ce(s(V), (oe, ge) => ({
              name: oe,
              fn: we((_e) => [
                ie(ne.$slots, oe, ze(Je(_e)))
              ])
            }))
          ]), 1040, ["months", "years", "month", "year", "instance", "onUpdateMonthYear"])),
          tt(Gr, He({
            ref: (oe) => {
              oe && (Y.value[K] = oe);
            },
            "mapped-dates": k.value(E),
            month: s(i)(E),
            year: s(g)(E),
            instance: E
          }, ne.$props, {
            onSelectDate: (oe) => s(A)(oe, E !== 1),
            onHandleSpace: (oe) => re(oe, E !== 1),
            onSetHoverDate: r[3] || (r[3] = (oe) => s(O)(oe)),
            onHandleScroll: (oe) => s(C)(oe, E),
            onHandleSwipe: (oe) => s(M)(oe, E),
            onMount: r[4] || (r[4] = (oe) => q(s(Ot).calendar)),
            onResetFlow: r[5] || (r[5] = (oe) => ne.$emit("reset-flow")),
            onTooltipOpen: r[6] || (r[6] = (oe) => ne.$emit("tooltip-open", oe)),
            onTooltipClose: r[7] || (r[7] = (oe) => ne.$emit("tooltip-close", oe))
          }), Ge({ _: 2 }, [
            Ce(s(y), (oe, ge) => ({
              name: oe,
              fn: we((_e) => [
                ie(ne.$slots, oe, ze(Je({ ..._e })))
              ])
            }))
          ]), 1040, ["mapped-dates", "month", "year", "instance", "onSelectDate", "onHandleSpace", "onHandleScroll", "onHandleSwipe"])
        ]),
        _: 3
      }, 8, ["multi-calendars", "collapse", "is-mobile"]),
      ne.enableTimePicker ? (w(), W("div", qr, [
        ne.$slots["time-picker"] ? ie(ne.$slots, "time-picker", ze(He({ key: 0 }, { time: s(P), updateTime: s(le) }))) : (w(), Te(Kn, He({
          key: 1,
          ref_key: "timePickerRef",
          ref: te
        }, ne.$props, {
          hours: s(P).hours,
          minutes: s(P).minutes,
          seconds: s(P).seconds,
          "internal-model-value": ne.internalModelValue,
          "disabled-times-config": s(v),
          "validate-time": s(h),
          onMount: r[8] || (r[8] = (E) => q(s(Ot).timePicker)),
          "onUpdate:hours": r[9] || (r[9] = (E) => s(le)(E)),
          "onUpdate:minutes": r[10] || (r[10] = (E) => s(le)(E, !1)),
          "onUpdate:seconds": r[11] || (r[11] = (E) => s(le)(E, !1, !0)),
          onResetFlow: r[12] || (r[12] = (E) => ne.$emit("reset-flow")),
          onOverlayClosed: r[13] || (r[13] = (E) => B(E, !1)),
          onOverlayOpened: r[14] || (r[14] = (E) => B(E, !0)),
          onAmPmChange: r[15] || (r[15] = (E) => ne.$emit("am-pm-change", E))
        }), Ge({ _: 2 }, [
          Ce(s(S), (E, K) => ({
            name: E,
            fn: we((oe) => [
              ie(ne.$slots, E, ze(Je(oe)))
            ])
          }))
        ]), 1040, ["hours", "minutes", "seconds", "internal-model-value", "disabled-times-config", "validate-time"]))
      ])) : Q("", !0)
    ], 64));
  }
}), Jr = (e, t) => {
  const l = Z(), {
    defaultedMultiCalendars: n,
    defaultedConfig: a,
    defaultedHighlight: f,
    defaultedRange: i,
    propDates: g,
    defaultedFilters: d,
    defaultedMultiDates: P
  } = Oe(e), { modelValue: v, year: R, month: h, calendars: T } = na(e, t), { isDisabled: F } = Tt(e), { selectYear: _, groupedYears: C, showYearPicker: M, isDisabled: A, toggleYearPicker: m, handleYearSelect: z, handleYear: L } = jn({
    modelValue: v,
    multiCalendars: n,
    range: i,
    highlight: f,
    calendars: T,
    propDates: g,
    month: h,
    year: R,
    filters: d,
    props: e,
    emit: t
  }), le = (y, V) => [y, V].map((S) => ft(S, "MMMM", { locale: e.formatLocale })).join("-"), U = j(() => (y) => v.value ? Array.isArray(v.value) ? v.value.some((V) => rn(y, V)) : rn(v.value, y) : !1), $ = (y) => {
    if (i.value.enabled) {
      if (Array.isArray(v.value)) {
        const V = $e(y, v.value[0]) || $e(y, v.value[1]);
        return xt(v.value, l.value, y) && !V;
      }
      return !1;
    }
    return !1;
  }, ee = (y, V) => y.quarter === sn(V) && y.year === ye(V), O = (y) => typeof f.value == "function" ? f.value({ quarter: sn(y), year: ye(y) }) : !!f.value.quarters.find((V) => ee(V, y)), J = j(() => (y) => {
    const V = Se(/* @__PURE__ */ new Date(), { year: R.value(y) });
    return yl({
      start: Gt(V),
      end: An(V)
    }).map((S) => {
      const q = hl(S), k = on(S), se = F(S), u = $(q), re = O(q);
      return {
        text: le(q, k),
        value: q,
        active: U.value(q),
        highlighted: re,
        disabled: se,
        isBetween: u
      };
    });
  }), ce = (y) => {
    en(y, v, P.value.limit), t("auto-apply", !0);
  }, pe = (y) => {
    v.value = tn(v, y, t), pa(v.value, t, e.autoApply, e.modelAuto);
  }, p = (y) => {
    v.value = y, t("auto-apply");
  };
  return {
    defaultedConfig: a,
    defaultedMultiCalendars: n,
    groupedYears: C,
    year: R,
    isDisabled: A,
    quarters: J,
    showYearPicker: M,
    modelValue: v,
    setHoverDate: (y) => {
      l.value = y;
    },
    selectYear: _,
    selectQuarter: (y, V, S) => {
      if (!S)
        return T.value[V].month = Me(on(y)), P.value.enabled ? ce(y) : i.value.enabled ? pe(y) : p(y);
    },
    toggleYearPicker: m,
    handleYearSelect: z,
    handleYear: L
  };
}, Zr = { class: "dp--quarter-items" }, xr = ["data-test-id", "disabled", "onClick", "onMouseover"], eo = /* @__PURE__ */ We({
  compatConfig: {
    MODE: 3
  },
  __name: "QuarterPicker",
  props: {
    ...dt
  },
  emits: [
    "update:internal-model-value",
    "reset-flow",
    "overlay-closed",
    "auto-apply",
    "range-start",
    "range-end",
    "overlay-toggle",
    "update-month-year"
  ],
  setup(e, { expose: t, emit: l }) {
    const n = l, a = e, f = Yt(), i = et(f, "yearMode"), {
      defaultedMultiCalendars: g,
      defaultedConfig: d,
      groupedYears: P,
      year: v,
      isDisabled: R,
      quarters: h,
      modelValue: T,
      showYearPicker: F,
      setHoverDate: _,
      selectQuarter: C,
      toggleYearPicker: M,
      handleYearSelect: A,
      handleYear: m
    } = Jr(a, n);
    return t({ getSidebarProps: () => ({
      modelValue: T,
      year: v,
      selectQuarter: C,
      handleYearSelect: A,
      handleYear: m
    }) }), (L, le) => (w(), Te(ma, {
      "multi-calendars": s(g).count,
      collapse: L.collapse,
      stretch: "",
      "is-mobile": L.isMobile
    }, {
      default: we(({ instance: U }) => [
        he("div", {
          class: "dp-quarter-picker-wrap",
          style: lt({ minHeight: `${s(d).modeHeight}px` })
        }, [
          L.$slots["top-extra"] ? ie(L.$slots, "top-extra", {
            key: 0,
            value: L.internalModelValue
          }) : Q("", !0),
          he("div", null, [
            tt(Wn, He(L.$props, {
              items: s(P)(U),
              instance: U,
              "show-year-picker": s(F)[U],
              year: s(v)(U),
              "is-disabled": ($) => s(R)(U, $),
              onHandleYear: ($) => s(m)(U, $),
              onYearSelect: ($) => s(A)($, U),
              onToggleYearPicker: ($) => s(M)(U, $?.flow, $?.show)
            }), Ge({ _: 2 }, [
              Ce(s(i), ($, ee) => ({
                name: $,
                fn: we((O) => [
                  ie(L.$slots, $, ze(Je(O)))
                ])
              }))
            ]), 1040, ["items", "instance", "show-year-picker", "year", "is-disabled", "onHandleYear", "onYearSelect", "onToggleYearPicker"])
          ]),
          he("div", Zr, [
            (w(!0), W(ke, null, Ce(s(h)(U), ($, ee) => (w(), W("div", { key: ee }, [
              he("button", {
                type: "button",
                class: De(["dp--qr-btn", {
                  "dp--qr-btn-active": $.active,
                  "dp--qr-btn-between": $.isBetween,
                  "dp--qr-btn-disabled": $.disabled,
                  "dp--highlighted": $.highlighted
                }]),
                "data-test-id": $.value,
                disabled: $.disabled,
                onClick: (O) => s(C)($.value, U, $.disabled),
                onMouseover: (O) => s(_)($.value)
              }, [
                L.$slots.quarter ? ie(L.$slots, "quarter", {
                  key: 0,
                  value: $.value,
                  text: $.text
                }) : (w(), W(ke, { key: 1 }, [
                  gt(Ke($.text), 1)
                ], 64))
              ], 42, xr)
            ]))), 128))
          ])
        ], 4)
      ]),
      _: 3
    }, 8, ["multi-calendars", "collapse", "is-mobile"]));
  }
}), Qn = (e, t) => {
  const l = Z(0);
  Ue(() => {
    n(), window.addEventListener("resize", n, { passive: !0 });
  }), Ut(() => {
    window.removeEventListener("resize", n);
  });
  const n = () => {
    l.value = window.document.documentElement.clientWidth;
  };
  return {
    isMobile: j(
      () => l.value <= e.value.mobileBreakpoint && !t ? !0 : void 0
    )
  };
}, to = ["id", "tabindex", "role", "aria-label"], ao = {
  key: 0,
  class: "dp--menu-load-container"
}, no = {
  key: 1,
  class: "dp--menu-header"
}, lo = ["data-dp-mobile"], ro = {
  key: 0,
  class: "dp__sidebar_left"
}, oo = ["data-dp-mobile"], so = ["data-test-id", "data-dp-mobile", "onClick", "onKeydown"], uo = {
  key: 2,
  class: "dp__sidebar_right"
}, io = {
  key: 3,
  class: "dp__action_extra"
}, hn = /* @__PURE__ */ We({
  compatConfig: {
    MODE: 3
  },
  __name: "DatepickerMenu",
  props: {
    ...va,
    shadow: { type: Boolean, default: !1 },
    openOnTop: { type: Boolean, default: !1 },
    internalModelValue: { type: [Date, Array], default: null },
    noOverlayFocus: { type: Boolean, default: !1 },
    collapse: { type: Boolean, default: !1 },
    getInputRect: { type: Function, default: () => ({}) },
    isTextInputDate: { type: Boolean, default: !1 }
  },
  emits: [
    "close-picker",
    "select-date",
    "auto-apply",
    "time-update",
    "flow-step",
    "update-month-year",
    "invalid-select",
    "update:internal-model-value",
    "recalculate-position",
    "invalid-fixed-range",
    "tooltip-open",
    "tooltip-close",
    "time-picker-open",
    "time-picker-close",
    "am-pm-change",
    "range-start",
    "range-end",
    "auto-apply-invalid",
    "date-update",
    "invalid-date",
    "overlay-toggle",
    "menu-blur"
  ],
  setup(e, { expose: t, emit: l }) {
    const n = l, a = e, f = Z(null), i = j(() => {
      const { openOnTop: D, ...de } = a;
      return {
        ...de,
        isMobile: C.value,
        flowStep: pe.value,
        menuWrapRef: f.value
      };
    }), { setMenuFocused: g, setShiftKey: d, control: P } = Hn(), v = Yt(), { defaultedTextInput: R, defaultedInline: h, defaultedConfig: T, defaultedUI: F, handleEventPropagation: _ } = Oe(a), { isMobile: C } = Qn(T, a.shadow), M = Z(null), A = Z(0), m = Z(null), z = Z(!1), L = Z(null), le = Z(!1), U = (D) => {
      le.value = !0, T.value.allowPreventDefault && D.preventDefault(), Dt(D, T.value, !0);
    };
    Ue(() => {
      if (!a.shadow) {
        z.value = !0, $(), window.addEventListener("resize", $);
        const D = Le(f);
        D && !R.value.enabled && !h.value.enabled && (g(!0), q()), D && (D.addEventListener("pointerdown", U), D.addEventListener("mousedown", U));
      }
      document.addEventListener("mousedown", nt);
    }), Ut(() => {
      window.removeEventListener("resize", $), document.removeEventListener("mousedown", nt);
      const D = Le(f);
      D && (D.removeEventListener("pointerdown", U), D.removeEventListener("mousedown", U));
    });
    const $ = () => {
      const D = Le(m);
      D && (A.value = D.getBoundingClientRect().width);
    }, { arrowRight: ee, arrowLeft: O, arrowDown: J, arrowUp: ce } = At(), { flowStep: pe, updateFlowStep: p, childMount: Y, resetFlow: te, handleFlow: y } = po(a, n, L), V = j(() => a.monthPicker ? hr : a.yearPicker ? kr : a.timePicker ? Yr : a.quarterPicker ? eo : Xr), S = j(() => {
      if (T.value.arrowLeft) return T.value.arrowLeft;
      const D = f.value?.getBoundingClientRect(), de = a.getInputRect();
      return de?.width < A?.value && de?.left <= (D?.left ?? 0) ? `${de?.width / 2}px` : de?.right >= (D?.right ?? 0) && de?.width < A?.value ? `${A?.value - de?.width / 2}px` : "50%";
    }), q = () => {
      const D = Le(f);
      D && D.focus({ preventScroll: !0 });
    }, k = j(() => L.value?.getSidebarProps() || {}), se = () => {
      a.openOnTop && n("recalculate-position");
    }, u = et(v, "action"), re = j(() => a.monthPicker || a.yearPicker ? et(v, "monthYear") : a.timePicker ? et(v, "timePicker") : et(v, "shared")), G = j(() => a.openOnTop ? "dp__arrow_bottom" : "dp__arrow_top"), I = j(() => ({
      dp__menu_disabled: a.disabled,
      dp__menu_readonly: a.readonly,
      "dp-menu-loading": a.loading
    })), x = j(
      () => ({
        dp__menu: !0,
        dp__menu_index: !h.value.enabled,
        dp__relative: h.value.enabled,
        ...F.value.menu ?? {}
      })
    ), c = (D) => {
      Dt(D, T.value, !0);
    }, o = (D) => {
      a.escClose && (n("close-picker"), _(D));
    }, X = (D) => {
      if (a.arrowNavigation) {
        if (D === Qe.up) return ce();
        if (D === Qe.down) return J();
        if (D === Qe.left) return O();
        if (D === Qe.right) return ee();
      } else D === Qe.left || D === Qe.up ? r("handleArrow", Qe.left, 0, D === Qe.up) : r("handleArrow", Qe.right, 0, D === Qe.down);
    }, B = (D) => {
      d(D.shiftKey), !a.disableMonthYearSelect && D.code === Re.tab && D.target.classList.contains("dp__menu") && P.value.shiftKeyInMenu && (D.preventDefault(), Dt(D, T.value, !0), n("close-picker"));
    }, be = () => {
      q(), n("time-picker-close");
    }, Ae = (D) => {
      L.value?.toggleTimePicker(!1, !1), L.value?.toggleMonthPicker(!1, !1, D), L.value?.toggleYearPicker(!1, !1, D);
    }, ne = (D, de = 0) => D === "month" ? L.value?.toggleMonthPicker(!1, !0, de) : D === "year" ? L.value?.toggleYearPicker(!1, !0, de) : D === "time" ? L.value?.toggleTimePicker(!0, !1) : Ae(de), r = (D, ...de) => {
      L.value?.[D] && L.value?.[D](...de);
    }, E = () => {
      r("selectCurrentDate");
    }, K = (D, de) => {
      r("presetDate", el(D), de);
    }, oe = () => {
      r("clearHoverDate");
    }, ge = (D, de) => {
      r("updateMonthYear", D, de);
    }, _e = (D, de) => {
      D.preventDefault(), X(de);
    }, Ye = (D) => {
      if (B(D), D.key === Re.home || D.key === Re.end)
        return r(
          "selectWeekDate",
          D.key === Re.home,
          D.target.getAttribute("id")
        );
      switch ((D.key === Re.pageUp || D.key === Re.pageDown) && (D.shiftKey ? (r("changeYear", D.key === Re.pageUp), Fa(f.value, "overlay-year")?.focus()) : (r("changeMonth", D.key === Re.pageUp), Fa(f.value, D.key === Re.pageUp ? "action-prev" : "action-next")?.focus()), D.target.getAttribute("id") && f.value?.focus({ preventScroll: !0 })), D.key) {
        case Re.esc:
          return o(D);
        case Re.arrowLeft:
          return _e(D, Qe.left);
        case Re.arrowRight:
          return _e(D, Qe.right);
        case Re.arrowUp:
          return _e(D, Qe.up);
        case Re.arrowDown:
          return _e(D, Qe.down);
        default:
          return;
      }
    }, nt = (D) => {
      h.value.enabled && !h.value.input && !f.value?.contains(D.target) && le.value && (le.value = !1, n("menu-blur"));
    };
    return t({
      updateMonthYear: ge,
      switchView: ne,
      handleFlow: y,
      onValueCleared: () => {
        L.value?.setStartTime?.();
      }
    }), (D, de) => (w(), W("div", {
      id: D.uid ? `dp-menu-${D.uid}` : void 0,
      ref_key: "dpMenuRef",
      ref: f,
      tabindex: s(h).enabled ? void 0 : "0",
      role: s(h).enabled ? void 0 : "dialog",
      "aria-label": D.ariaLabels?.menu,
      class: De(x.value),
      style: lt({ "--dp-arrow-left": S.value }),
      onMouseleave: oe,
      onClick: c,
      onKeydown: Ye
    }, [
      (D.disabled || D.readonly) && s(h).enabled || D.loading ? (w(), W("div", {
        key: 0,
        class: De(I.value)
      }, [
        D.loading ? (w(), W("div", ao, [...de[19] || (de[19] = [
          he("span", { class: "dp--menu-loader" }, null, -1)
        ])])) : Q("", !0)
      ], 2)) : Q("", !0),
      D.$slots["menu-header"] ? (w(), W("div", no, [
        ie(D.$slots, "menu-header")
      ])) : Q("", !0),
      !s(h).enabled && !D.teleportCenter ? (w(), W("div", {
        key: 2,
        class: De(G.value)
      }, null, 2)) : Q("", !0),
      he("div", {
        ref_key: "innerMenuRef",
        ref: m,
        class: De({
          dp__menu_content_wrapper: D.presetDates?.length || !!D.$slots["left-sidebar"] || !!D.$slots["right-sidebar"],
          "dp--menu-content-wrapper-collapsed": e.collapse && (D.presetDates?.length || !!D.$slots["left-sidebar"] || !!D.$slots["right-sidebar"])
        }),
        "data-dp-mobile": s(C),
        style: lt({ "--dp-menu-width": `${A.value}px` })
      }, [
        D.$slots["left-sidebar"] ? (w(), W("div", ro, [
          ie(D.$slots, "left-sidebar", ze(Je(k.value)))
        ])) : Q("", !0),
        D.presetDates.length ? (w(), W("div", {
          key: 1,
          class: De({ "dp--preset-dates-collapsed": e.collapse, "dp--preset-dates": !0 }),
          "data-dp-mobile": s(C)
        }, [
          (w(!0), W(ke, null, Ce(D.presetDates, (fe, ht) => (w(), W(ke, { key: ht }, [
            fe.slot ? ie(D.$slots, fe.slot, {
              key: 0,
              presetDate: K,
              label: fe.label,
              value: fe.value
            }) : (w(), W("button", {
              key: 1,
              type: "button",
              style: lt(fe.style || {}),
              class: De(["dp__btn dp--preset-range", { "dp--preset-range-collapsed": e.collapse }]),
              "data-test-id": fe.testId ?? void 0,
              "data-dp-mobile": s(C),
              onClick: Xt((xe) => K(fe.value, fe.noTz), ["prevent"]),
              onKeydown: (xe) => s(qe)(xe, () => K(fe.value, fe.noTz), !0)
            }, Ke(fe.label), 47, so))
          ], 64))), 128))
        ], 10, oo)) : Q("", !0),
        he("div", {
          ref_key: "calendarWrapperRef",
          ref: M,
          class: "dp__instance_calendar",
          role: "document"
        }, [
          (w(), Te(fa(V.value), He({
            ref_key: "dynCmpRef",
            ref: L
          }, i.value, {
            "flow-step": s(pe),
            onMount: s(Y),
            onUpdateFlowStep: s(p),
            onResetFlow: s(te),
            onFocusMenu: q,
            onSelectDate: de[0] || (de[0] = (fe) => D.$emit("select-date")),
            onDateUpdate: de[1] || (de[1] = (fe) => D.$emit("date-update", fe)),
            onTooltipOpen: de[2] || (de[2] = (fe) => D.$emit("tooltip-open", fe)),
            onTooltipClose: de[3] || (de[3] = (fe) => D.$emit("tooltip-close", fe)),
            onAutoApply: de[4] || (de[4] = (fe) => D.$emit("auto-apply", fe)),
            onRangeStart: de[5] || (de[5] = (fe) => D.$emit("range-start", fe)),
            onRangeEnd: de[6] || (de[6] = (fe) => D.$emit("range-end", fe)),
            onInvalidFixedRange: de[7] || (de[7] = (fe) => D.$emit("invalid-fixed-range", fe)),
            onTimeUpdate: de[8] || (de[8] = (fe) => D.$emit("time-update")),
            onAmPmChange: de[9] || (de[9] = (fe) => D.$emit("am-pm-change", fe)),
            onTimePickerOpen: de[10] || (de[10] = (fe) => D.$emit("time-picker-open", fe)),
            onTimePickerClose: be,
            onRecalculatePosition: se,
            onUpdateMonthYear: de[11] || (de[11] = (fe) => D.$emit("update-month-year", fe)),
            onAutoApplyInvalid: de[12] || (de[12] = (fe) => D.$emit("auto-apply-invalid", fe)),
            onInvalidDate: de[13] || (de[13] = (fe) => D.$emit("invalid-date", fe)),
            onOverlayToggle: de[14] || (de[14] = (fe) => D.$emit("overlay-toggle", fe)),
            "onUpdate:internalModelValue": de[15] || (de[15] = (fe) => D.$emit("update:internal-model-value", fe))
          }), Ge({ _: 2 }, [
            Ce(re.value, (fe, ht) => ({
              name: fe,
              fn: we((xe) => [
                ie(D.$slots, fe, ze(Je({ ...xe })))
              ])
            }))
          ]), 1040, ["flow-step", "onMount", "onUpdateFlowStep", "onResetFlow"]))
        ], 512),
        D.$slots["right-sidebar"] ? (w(), W("div", uo, [
          ie(D.$slots, "right-sidebar", ze(Je(k.value)))
        ])) : Q("", !0),
        D.$slots["action-extra"] ? (w(), W("div", io, [
          D.$slots["action-extra"] ? ie(D.$slots, "action-extra", {
            key: 0,
            selectCurrentDate: E
          }) : Q("", !0)
        ])) : Q("", !0)
      ], 14, lo),
      !D.autoApply || s(T).keepActionRow ? (w(), Te(ir, He({
        key: 3,
        "menu-mount": z.value
      }, i.value, {
        "calendar-width": A.value,
        onClosePicker: de[16] || (de[16] = (fe) => D.$emit("close-picker")),
        onSelectDate: de[17] || (de[17] = (fe) => D.$emit("select-date")),
        onInvalidSelect: de[18] || (de[18] = (fe) => D.$emit("invalid-select")),
        onSelectNow: E
      }), Ge({ _: 2 }, [
        Ce(s(u), (fe, ht) => ({
          name: fe,
          fn: we((xe) => [
            ie(D.$slots, fe, ze(Je({ ...xe })))
          ])
        }))
      ]), 1040, ["menu-mount", "calendar-width"])) : Q("", !0)
    ], 46, to));
  }
});
var Et = /* @__PURE__ */ ((e) => (e.center = "center", e.left = "left", e.right = "right", e))(Et || {});
const co = ({
  menuRef: e,
  menuRefInner: t,
  inputRef: l,
  pickerWrapperRef: n,
  inline: a,
  emit: f,
  props: i,
  slots: g
}) => {
  const { defaultedConfig: d } = Oe(i), P = Z({}), v = Z(!1), R = Z({
    top: "0",
    left: "0"
  }), h = Z(!1), T = qt(i, "teleportCenter");
  rt(T, () => {
    R.value = JSON.parse(JSON.stringify({})), L();
  });
  const F = (y) => {
    if (i.teleport) {
      const V = y.getBoundingClientRect();
      return {
        left: V.left + window.scrollX,
        top: V.top + window.scrollY
      };
    }
    return { top: 0, left: 0 };
  }, _ = (y, V) => {
    R.value.left = `${y + V - P.value.width}px`;
  }, C = (y) => {
    R.value.left = `${y}px`;
  }, M = (y, V) => {
    i.position === Et.left && C(y), i.position === Et.right && _(y, V), i.position === Et.center && (R.value.left = `${y + V / 2 - P.value.width / 2}px`);
  }, A = (y) => {
    const { width: V, height: S } = y.getBoundingClientRect(), { top: q, left: k } = F(y);
    return { top: +q, left: +k, width: V, height: S };
  }, m = () => {
    R.value.left = "50%", R.value.top = "50%", R.value.transform = "translate(-50%, -50%)", R.value.position = "fixed", delete R.value.opacity;
  }, z = () => {
    const y = Le(l);
    R.value = i.altPosition(y);
  }, L = (y = !0) => {
    if (!a.value.enabled) {
      if (T.value) return m();
      if (i.altPosition !== null) return z();
      if (y) {
        const V = i.teleport ? t.value?.$el : e.value;
        V && (P.value = V.getBoundingClientRect()), f("recalculate-position");
      }
      return ce();
    }
  }, le = ({ inputEl: y, left: V, width: S }) => {
    window.screen.width > 768 && !v.value && M(V, S), ee(y);
  }, U = (y) => {
    const { top: V, left: S, height: q, width: k } = A(y);
    R.value.top = `${q + V + +i.offset}px`, h.value = !1, v.value || (R.value.left = `${S + k / 2 - P.value.width / 2}px`), le({ inputEl: y, left: S, width: k });
  }, $ = (y) => {
    const { top: V, left: S, width: q } = A(y);
    R.value.top = `${V - +i.offset - P.value.height}px`, h.value = !0, le({ inputEl: y, left: S, width: q });
  }, ee = (y) => {
    if (i.autoPosition) {
      const { left: V, width: S } = A(y), { left: q, right: k } = P.value;
      if (!v.value) {
        if (Math.abs(q) !== Math.abs(k)) {
          if (q <= 0)
            return v.value = !0, C(V);
          if (k >= document.documentElement.clientWidth)
            return v.value = !0, _(V, S);
        }
        return M(V, S);
      }
    }
  }, O = () => {
    const y = Le(l);
    if (y) {
      if (i.autoPosition === st.top) return st.top;
      if (i.autoPosition === st.bottom) return st.bottom;
      const { height: V } = P.value, { top: S, height: q } = y.getBoundingClientRect(), se = window.innerHeight - S - q, u = S;
      return V <= se ? st.bottom : V > se && V <= u ? st.top : se >= u ? st.bottom : st.top;
    }
    return st.bottom;
  }, J = (y) => O() === st.bottom ? U(y) : $(y), ce = () => {
    const y = Le(l);
    if (y)
      return i.autoPosition ? J(y) : U(y);
  }, pe = function(y) {
    if (y) {
      const V = y.scrollHeight > y.clientHeight, q = window.getComputedStyle(y).overflowY.indexOf("hidden") !== -1;
      return V && !q;
    }
    return !0;
  }, p = function(y) {
    return !y || y === document.body || y.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? window : pe(y) ? y : p(
      y.assignedSlot && d.value.shadowDom ? y.assignedSlot.parentNode : y.parentNode
    );
  }, Y = (y) => {
    if (y)
      switch (i.position) {
        case Et.left:
          return { left: 0, transform: "translateX(0)" };
        case Et.right:
          return { left: `${y.width}px`, transform: "translateX(-100%)" };
        default:
          return { left: `${y.width / 2}px`, transform: "translateX(-50%)" };
      }
    return {};
  };
  return {
    openOnTop: h,
    menuStyle: R,
    xCorrect: v,
    setMenuPosition: L,
    getScrollableParent: p,
    shadowRender: (y, V, S) => {
      const q = document.createElement("div"), k = Le(l)?.getBoundingClientRect();
      q.setAttribute("id", "dp--temp-container");
      const se = n.value?.clientWidth ? n.value : document.body;
      se.append(q);
      const u = Y(k), re = d.value.shadowDom ? Object.keys(g).filter(
        (I) => ["right-sidebar", "left-sidebar", "top-extra", "action-extra"].includes(I)
      ) : Object.keys(g), G = tl(
        V,
        {
          ...S,
          shadow: !0,
          style: { opacity: 0, position: "absolute", ...u }
        },
        Object.fromEntries(re.map((I) => [I, g[I]]))
      );
      y != null && (G.appContext = y.appContext), nn(G, q), P.value = G.el?.getBoundingClientRect(), nn(null, q), se.removeChild(q);
    }
  };
}, bt = [
  { name: "clock-icon", use: ["time", "calendar", "shared"] },
  { name: "arrow-left", use: ["month-year", "calendar", "shared", "year-mode"] },
  { name: "arrow-right", use: ["month-year", "calendar", "shared", "year-mode"] },
  { name: "arrow-up", use: ["time", "calendar", "month-year", "shared"] },
  { name: "arrow-down", use: ["time", "calendar", "month-year", "shared"] },
  { name: "calendar-icon", use: ["month-year", "time", "calendar", "shared", "year-mode"] },
  { name: "day", use: ["calendar", "shared"] },
  { name: "month-overlay-value", use: ["calendar", "month-year", "shared"] },
  { name: "year-overlay-value", use: ["calendar", "month-year", "shared", "year-mode"] },
  { name: "year-overlay", use: ["month-year", "shared"] },
  { name: "month-overlay", use: ["month-year", "shared"] },
  { name: "month-overlay-header", use: ["month-year", "shared"] },
  { name: "year-overlay-header", use: ["month-year", "shared"] },
  { name: "hours-overlay-value", use: ["calendar", "time", "shared"] },
  { name: "hours-overlay-header", use: ["calendar", "time", "shared"] },
  { name: "minutes-overlay-value", use: ["calendar", "time", "shared"] },
  { name: "minutes-overlay-header", use: ["calendar", "time", "shared"] },
  { name: "seconds-overlay-value", use: ["calendar", "time", "shared"] },
  { name: "seconds-overlay-header", use: ["calendar", "time", "shared"] },
  { name: "hours", use: ["calendar", "time", "shared"] },
  { name: "minutes", use: ["calendar", "time", "shared"] },
  { name: "month", use: ["calendar", "month-year", "shared"] },
  { name: "year", use: ["calendar", "month-year", "shared", "year-mode"] },
  { name: "action-buttons", use: ["action"] },
  { name: "action-preview", use: ["action"] },
  { name: "calendar-header", use: ["calendar", "shared"] },
  { name: "marker-tooltip", use: ["calendar", "shared"] },
  { name: "action-extra", use: ["menu"] },
  { name: "time-picker-overlay", use: ["calendar", "time", "shared"] },
  { name: "am-pm-button", use: ["calendar", "time", "shared"] },
  { name: "left-sidebar", use: ["menu"] },
  { name: "right-sidebar", use: ["menu"] },
  { name: "month-year", use: ["month-year", "shared"] },
  { name: "time-picker", use: ["menu", "shared"] },
  { name: "action-row", use: ["action"] },
  { name: "marker", use: ["calendar", "shared"] },
  { name: "quarter", use: ["shared"] },
  { name: "top-extra", use: ["shared", "month-year"] },
  { name: "tp-inline-arrow-up", use: ["shared", "time"] },
  { name: "tp-inline-arrow-down", use: ["shared", "time"] },
  { name: "menu-header", use: ["menu"] }
], fo = [{ name: "trigger" }, { name: "input-icon" }, { name: "clear-icon" }, { name: "dp-input" }], vo = {
  all: () => bt,
  monthYear: () => bt.filter((e) => e.use.includes("month-year")),
  input: () => fo,
  timePicker: () => bt.filter((e) => e.use.includes("time")),
  action: () => bt.filter((e) => e.use.includes("action")),
  calendar: () => bt.filter((e) => e.use.includes("calendar")),
  menu: () => bt.filter((e) => e.use.includes("menu")),
  shared: () => bt.filter((e) => e.use.includes("shared")),
  yearMode: () => bt.filter((e) => e.use.includes("year-mode"))
}, et = (e, t, l) => {
  const n = [];
  return vo[t]().forEach((a) => {
    e[a.name] && n.push(a.name);
  }), l?.length && l.forEach((a) => {
    a.slot && n.push(a.slot);
  }), n;
}, aa = (e) => {
  const t = j(() => (n) => e.value ? n ? e.value.open : e.value.close : ""), l = j(() => (n) => e.value ? n ? e.value.menuAppearTop : e.value.menuAppearBottom : "");
  return { transitionName: t, showTransition: !!e.value, menuTransition: l };
}, na = (e, t, l) => {
  const { defaultedRange: n, defaultedTz: a } = Oe(e), f = H(Ze(H(), a.value.timezone)), i = Z([{ month: Me(f), year: ye(f) }]), g = (h) => {
    const T = {
      hours: yt(f),
      minutes: $t(f),
      seconds: 0
    };
    return n.value.enabled ? [T[h], T[h]] : T[h];
  }, d = ea({
    hours: g("hours"),
    minutes: g("minutes"),
    seconds: g("seconds")
  });
  rt(
    n,
    (h, T) => {
      h.enabled !== T.enabled && (d.hours = g("hours"), d.minutes = g("minutes"), d.seconds = g("seconds"));
    },
    { deep: !0 }
  );
  const P = j({
    get: () => e.internalModelValue,
    set: (h) => {
      !e.readonly && !e.disabled && t("update:internal-model-value", h);
    }
  }), v = j(
    () => (h) => i.value[h] ? i.value[h].month : 0
  ), R = j(
    () => (h) => i.value[h] ? i.value[h].year : 0
  );
  return rt(
    P,
    (h, T) => {
      l && JSON.stringify(h ?? {}) !== JSON.stringify(T ?? {}) && l();
    },
    { deep: !0 }
  ), {
    calendars: i,
    time: d,
    modelValue: P,
    month: v,
    year: R,
    today: f
  };
}, mo = (e, t) => {
  const {
    defaultedMultiCalendars: l,
    defaultedMultiDates: n,
    defaultedUI: a,
    defaultedHighlight: f,
    defaultedTz: i,
    propDates: g,
    defaultedRange: d
  } = Oe(t), { isDisabled: P } = Tt(t), v = Z(null), R = Z(Ze(/* @__PURE__ */ new Date(), i.value.timezone)), h = (c) => {
    !c.current && t.hideOffsetDates || (v.value = c.value);
  }, T = () => {
    v.value = null;
  }, F = (c) => Array.isArray(e.value) && d.value.enabled && e.value[0] && v.value ? c ? Ee(v.value, e.value[0]) : Be(v.value, e.value[0]) : !0, _ = (c, o) => {
    const X = () => e.value ? o ? e.value[0] || null : e.value[1] : null, B = e.value && Array.isArray(e.value) ? X() : null;
    return $e(H(c.value), B);
  }, C = (c) => {
    const o = Array.isArray(e.value) ? e.value[0] : null;
    return c ? !Be(v.value ?? null, o) : !0;
  }, M = (c, o = !0) => (d.value.enabled || t.weekPicker) && Array.isArray(e.value) && e.value.length === 2 ? t.hideOffsetDates && !c.current ? !1 : $e(H(c.value), e.value[o ? 0 : 1]) : d.value.enabled ? _(c, o) && C(o) || $e(c.value, Array.isArray(e.value) ? e.value[0] : null) && F(o) : !1, A = (c, o) => {
    if (Array.isArray(e.value) && e.value[0] && e.value.length === 1) {
      const X = $e(c.value, v.value);
      return o ? Ee(e.value[0], c.value) && X : Be(e.value[0], c.value) && X;
    }
    return !1;
  }, m = (c) => !e.value || t.hideOffsetDates && !c.current ? !1 : d.value.enabled ? t.modelAuto && Array.isArray(e.value) ? $e(c.value, e.value[0] ? e.value[0] : R.value) : !1 : n.value.enabled && Array.isArray(e.value) ? e.value.some((o) => $e(o, c.value)) : $e(c.value, e.value ? e.value : R.value), z = (c) => {
    if (d.value.autoRange || t.weekPicker) {
      if (v.value) {
        if (t.hideOffsetDates && !c.current) return !1;
        const o = kt(v.value, +d.value.autoRange), X = mt(H(v.value), t.weekStart);
        return t.weekPicker ? $e(X[1], H(c.value)) : $e(o, H(c.value));
      }
      return !1;
    }
    return !1;
  }, L = (c) => {
    if (d.value.autoRange || t.weekPicker) {
      if (v.value) {
        const o = kt(v.value, +d.value.autoRange);
        if (t.hideOffsetDates && !c.current) return !1;
        const X = mt(H(v.value), t.weekStart);
        return t.weekPicker ? Ee(c.value, X[0]) && Be(c.value, X[1]) : Ee(c.value, v.value) && Be(c.value, o);
      }
      return !1;
    }
    return !1;
  }, le = (c) => {
    if (d.value.autoRange || t.weekPicker) {
      if (v.value) {
        if (t.hideOffsetDates && !c.current) return !1;
        const o = mt(H(v.value), t.weekStart);
        return t.weekPicker ? $e(o[0], c.value) : $e(v.value, c.value);
      }
      return !1;
    }
    return !1;
  }, U = (c) => xt(e.value, v.value, c.value), $ = () => t.modelAuto && Array.isArray(t.internalModelValue) ? !!t.internalModelValue[0] : !1, ee = () => t.modelAuto ? Rn(t.internalModelValue) : !0, O = (c) => {
    if (t.weekPicker) return !1;
    const o = d.value.enabled ? !M(c) && !M(c, !1) : !0;
    return !P(c.value) && !m(c) && !(!c.current && t.hideOffsetDates) && o;
  }, J = (c) => d.value.enabled ? t.modelAuto ? $() && m(c) : !1 : m(c), ce = (c) => f.value ? Bl(c.value, g.value.highlight) : !1, pe = (c) => {
    const o = P(c.value);
    return o && (typeof f.value == "function" ? !f.value(c.value, o) : !f.value.options.highlightDisabled);
  }, p = (c) => typeof f.value == "function" ? f.value(c.value) : f.value.weekdays?.includes(c.value.getDay()), Y = (c) => (d.value.enabled || t.weekPicker) && (!(l.value.count > 0) || c.current) && ee() && !(!c.current && t.hideOffsetDates) && !m(c) ? U(c) : !1, te = (c) => {
    if (Array.isArray(e.value) && e.value.length === 1) {
      const { before: o, after: X } = mn(+d.value.maxRange, e.value[0]);
      return Ft(c.value, o) || _t(c.value, X);
    }
    return !1;
  }, y = (c) => {
    if (Array.isArray(e.value) && e.value.length === 1) {
      const { before: o, after: X } = mn(+d.value.minRange, e.value[0]);
      return xt([o, X], e.value[0], c.value);
    }
    return !1;
  }, V = (c) => d.value.enabled && (d.value.maxRange || d.value.minRange) ? d.value.maxRange && d.value.minRange ? te(c) || y(c) : d.value.maxRange ? te(c) : y(c) : !1, S = (c) => {
    const { isRangeStart: o, isRangeEnd: X } = u(c), B = d.value.enabled ? o || X : !1;
    return {
      dp__cell_offset: !c.current,
      dp__pointer: !t.disabled && !(!c.current && t.hideOffsetDates) && !P(c.value) && !V(c),
      dp__cell_disabled: P(c.value) || V(c),
      dp__cell_highlight: !pe(c) && (ce(c) || p(c)) && !J(c) && !B && !le(c) && !(Y(c) && t.weekPicker) && !X,
      dp__cell_highlight_active: !pe(c) && (ce(c) || p(c)) && J(c),
      dp__today: !t.noToday && $e(c.value, R.value) && c.current,
      "dp--past": Be(c.value, R.value),
      "dp--future": Ee(c.value, R.value)
    };
  }, q = (c) => ({
    dp__active_date: J(c),
    dp__date_hover: O(c)
  }), k = (c) => {
    if (e.value && !Array.isArray(e.value)) {
      const o = mt(e.value, t.weekStart);
      return {
        ...G(c),
        dp__range_start: $e(o[0], c.value),
        dp__range_end: $e(o[1], c.value),
        dp__range_between_week: Ee(c.value, o[0]) && Be(c.value, o[1])
      };
    }
    return {
      ...G(c)
    };
  }, se = (c) => {
    if (e.value && Array.isArray(e.value)) {
      const o = mt(e.value[0], t.weekStart), X = e.value[1] ? mt(e.value[1], t.weekStart) : [];
      return {
        ...G(c),
        dp__range_start: $e(o[0], c.value) || $e(X[0], c.value),
        dp__range_end: $e(o[1], c.value) || $e(X[1], c.value),
        dp__range_between_week: Ee(c.value, o[0]) && Be(c.value, o[1]) || Ee(c.value, X[0]) && Be(c.value, X[1]),
        dp__range_between: Ee(c.value, o[1]) && Be(c.value, X[0])
      };
    }
    return {
      ...G(c)
    };
  }, u = (c) => {
    const o = l.value.count > 0 ? c.current && M(c) && ee() : M(c) && ee(), X = l.value.count > 0 ? c.current && M(c, !1) && ee() : M(c, !1) && ee();
    return { isRangeStart: o, isRangeEnd: X };
  }, re = (c) => {
    const { isRangeStart: o, isRangeEnd: X } = u(c);
    return {
      dp__range_start: o,
      dp__range_end: X,
      dp__range_between: Y(c),
      dp__date_hover: $e(c.value, v.value) && !o && !X && !t.weekPicker,
      dp__date_hover_start: A(c, !0),
      dp__date_hover_end: A(c, !1)
    };
  }, G = (c) => ({
    ...re(c),
    dp__cell_auto_range: L(c),
    dp__cell_auto_range_start: le(c),
    dp__cell_auto_range_end: z(c)
  }), I = (c) => d.value.enabled ? d.value.autoRange ? G(c) : t.modelAuto ? { ...q(c), ...re(c) } : t.weekPicker ? se(c) : re(c) : t.weekPicker ? k(c) : q(c);
  return {
    setHoverDate: h,
    clearHoverDate: T,
    getDayClassData: (c) => t.hideOffsetDates && !c.current ? {} : {
      ...S(c),
      ...I(c),
      [t.dayClass ? t.dayClass(c.value, t.internalModelValue) : ""]: !0,
      ...a.value.calendarCell ?? {}
    }
  };
}, Tt = (e) => {
  const { defaultedFilters: t, defaultedRange: l, propDates: n, defaultedMultiDates: a } = Oe(e), f = (p) => n.value.disabledDates ? typeof n.value.disabledDates == "function" ? n.value.disabledDates(H(p)) : !!ca(p, n.value.disabledDates) : !1, i = (p) => n.value.maxDate ? e.yearPicker ? ye(p) > ye(n.value.maxDate) : Ee(p, n.value.maxDate) : !1, g = (p) => n.value.minDate ? e.yearPicker ? ye(p) < ye(n.value.minDate) : Be(p, n.value.minDate) : !1, d = (p) => {
    const Y = i(p), te = g(p), y = f(p), S = t.value.months.map((re) => +re).includes(Me(p)), q = e.disabledWeekDays.length ? e.disabledWeekDays.some((re) => +re === kl(p)) : !1, k = T(p), se = ye(p), u = zn(e.yearRange, se);
    return !(Y || te || y || S || u || q || k);
  }, P = (p, Y) => Be(...wt(n.value.minDate, p, Y)) || $e(...wt(n.value.minDate, p, Y)), v = (p, Y) => Ee(...wt(n.value.maxDate, p, Y)) || $e(...wt(n.value.maxDate, p, Y)), R = (p, Y, te) => {
    let y = !1;
    return n.value.maxDate && te && v(p, Y) && (y = !0), n.value.minDate && !te && P(p, Y) && (y = !0), y;
  }, h = (p, Y, te, y) => {
    let V = !1;
    return y && (n.value.minDate || n.value.maxDate) ? n.value.minDate && n.value.maxDate ? V = R(p, Y, te) : (n.value.minDate && P(p, Y) || n.value.maxDate && v(p, Y)) && (V = !0) : V = !0, V;
  }, T = (p) => Array.isArray(n.value.allowedDates) && !n.value.allowedDates.length ? !0 : n.value.allowedDates ? !ca(p, n.value.allowedDates, On(e.monthPicker, e.yearPicker)) : !1, F = (p) => !d(p), _ = (p) => l.value.noDisabledRange ? !bn({ start: p[0], end: p[1] }).some((te) => F(te)) : !0, C = (p) => {
    if (p) {
      const Y = ye(p);
      return Y >= +e.yearRange[0] && Y <= e.yearRange[1];
    }
    return !0;
  }, M = (p, Y) => !!(Array.isArray(p) && p[Y] && (l.value.maxRange || l.value.minRange) && C(p[Y])), A = (p, Y, te = 0) => {
    if (M(Y, te) && C(p)) {
      const y = bl(p, Y[te]), V = In(Y[te], p), S = V.length === 1 ? 0 : V.filter((k) => F(k)).length, q = Math.abs(y) - (l.value.minMaxRawRange ? 0 : S);
      if (l.value.minRange && l.value.maxRange)
        return q >= +l.value.minRange && q <= +l.value.maxRange;
      if (l.value.minRange) return q >= +l.value.minRange;
      if (l.value.maxRange) return q <= +l.value.maxRange;
    }
    return !0;
  }, m = () => !e.enableTimePicker || e.monthPicker || e.yearPicker || e.ignoreTimeValidation, z = (p) => Array.isArray(p) ? [p[0] ? Ca(p[0]) : null, p[1] ? Ca(p[1]) : null] : Ca(p), L = (p, Y, te) => p.find(
    (y) => +y.hours === yt(Y) && y.minutes === "*" ? !0 : +y.minutes === $t(Y) && +y.hours === yt(Y)
  ) && te, le = (p, Y, te) => {
    const [y, V] = p, [S, q] = Y;
    return !L(y, S, te) && !L(V, q, te) && te;
  }, U = (p, Y) => {
    const te = Array.isArray(Y) ? Y : [Y];
    return Array.isArray(e.disabledTimes) ? Array.isArray(e.disabledTimes[0]) ? le(e.disabledTimes, te, p) : !te.some((y) => L(e.disabledTimes, y, p)) : p;
  }, $ = (p, Y) => {
    const te = Array.isArray(Y) ? [Bt(Y[0]), Y[1] ? Bt(Y[1]) : void 0] : Bt(Y), y = !e.disabledTimes(te);
    return p && y;
  }, ee = (p, Y) => e.disabledTimes ? Array.isArray(e.disabledTimes) ? U(Y, p) : $(Y, p) : Y, O = (p) => {
    let Y = !0;
    if (!p || m()) return !0;
    const te = !n.value.minDate && !n.value.maxDate ? z(p) : p;
    return (e.maxTime || n.value.maxDate) && (Y = vn(
      e.maxTime,
      n.value.maxDate,
      "max",
      Ne(te),
      Y
    )), (e.minTime || n.value.minDate) && (Y = vn(
      e.minTime,
      n.value.minDate,
      "min",
      Ne(te),
      Y
    )), ee(p, Y);
  }, J = (p) => {
    if (!e.monthPicker) return !0;
    let Y = !0;
    const te = H(it(p));
    if (n.value.minDate && n.value.maxDate) {
      const y = H(it(n.value.minDate)), V = H(it(n.value.maxDate));
      return Ee(te, y) && Be(te, V) || $e(te, y) || $e(te, V);
    }
    if (n.value.minDate) {
      const y = H(it(n.value.minDate));
      Y = Ee(te, y) || $e(te, y);
    }
    if (n.value.maxDate) {
      const y = H(it(n.value.maxDate));
      Y = Be(te, y) || $e(te, y);
    }
    return Y;
  }, ce = j(() => (p) => !e.enableTimePicker || e.ignoreTimeValidation ? !0 : O(p)), pe = j(() => (p) => e.monthPicker ? Array.isArray(p) && (l.value.enabled || a.value.enabled) ? !p.filter((te) => !J(te)).length : J(p) : !0);
  return {
    isDisabled: F,
    validateDate: d,
    validateMonthYearInRange: h,
    isDateRangeAllowed: _,
    checkMinMaxRange: A,
    isValidTime: O,
    isTimeValid: ce,
    isMonthValid: pe
  };
}, ga = () => {
  const e = j(() => (n, a) => n?.includes(a)), t = j(() => (n, a) => n.count ? n.solo ? !0 : a === 0 : !0), l = j(() => (n, a) => n.count ? n.solo ? !0 : a === n.count - 1 : !0);
  return { hideNavigationButtons: e, showLeftIcon: t, showRightIcon: l };
}, po = (e, t, l) => {
  const n = Z(0), a = ea({
    [Ot.timePicker]: !e.enableTimePicker || e.timePicker || e.monthPicker,
    [Ot.calendar]: !1,
    [Ot.header]: !1
  }), f = j(() => e.monthPicker || e.timePicker), i = (R) => {
    if (e.flow?.length) {
      if (!R && f.value) return v();
      a[R] = !0, Object.keys(a).filter((h) => !a[h]).length || v();
    }
  }, g = () => {
    e.flow?.length && n.value !== -1 && (n.value += 1, t("flow-step", n.value), v()), e.flow?.length === n.value && at().then(() => d());
  }, d = () => {
    n.value = -1;
  }, P = (R, h, ...T) => {
    e.flow[n.value] === R && l.value && l.value[h]?.(...T);
  }, v = (R = 0) => {
    R && (n.value += R), P(je.month, "toggleMonthPicker", !0), P(je.year, "toggleYearPicker", !0), P(je.calendar, "toggleTimePicker", !1, !0), P(je.time, "toggleTimePicker", !0, !0);
    const h = e.flow[n.value];
    (h === je.hours || h === je.minutes || h === je.seconds) && P(h, "toggleTimePicker", !0, !0, h);
  };
  return { childMount: i, updateFlowStep: g, resetFlow: d, handleFlow: v, flowStep: n };
}, go = {
  key: 1,
  class: "dp__input_wrap"
}, yo = ["id", "name", "inputmode", "placeholder", "disabled", "readonly", "required", "value", "autocomplete", "aria-label", "aria-disabled", "aria-invalid"], ho = {
  key: 2,
  class: "dp--clear-btn"
}, bo = ["aria-label"], ko = /* @__PURE__ */ We({
  compatConfig: {
    MODE: 3
  },
  __name: "DatepickerInput",
  props: {
    isMenuOpen: { type: Boolean, default: !1 },
    inputValue: { type: String, default: "" },
    ...va
  },
  emits: [
    "clear",
    "open",
    "update:input-value",
    "set-input-date",
    "close",
    "select-date",
    "set-empty-date",
    "toggle",
    "focus-prev",
    "focus",
    "blur",
    "real-blur",
    "text-input"
  ],
  setup(e, { expose: t, emit: l }) {
    const n = l, a = e, {
      defaultedTextInput: f,
      defaultedAriaLabels: i,
      defaultedInline: g,
      defaultedConfig: d,
      defaultedRange: P,
      defaultedMultiDates: v,
      defaultedUI: R,
      getDefaultPattern: h,
      getDefaultStartTime: T
    } = Oe(a), { checkMinMaxRange: F } = Tt(a), _ = Z(), C = Z(null), M = Z(!1), A = Z(!1), m = j(
      () => ({
        dp__pointer: !a.disabled && !a.readonly && !f.value.enabled,
        dp__disabled: a.disabled,
        dp__input_readonly: !f.value.enabled,
        dp__input: !0,
        dp__input_not_clearable: !a.clearable,
        dp__input_icon_pad: !a.hideInputIcon,
        dp__input_valid: typeof a.state == "boolean" ? a.state : !1,
        dp__input_invalid: typeof a.state == "boolean" ? !a.state : !1,
        dp__input_focus: M.value || a.isMenuOpen,
        dp__input_reg: !f.value.enabled,
        ...R.value.input ?? {}
      })
    ), z = () => {
      n("set-input-date", null), a.clearable && a.autoApply && (n("set-empty-date"), _.value = null);
    }, L = (k) => {
      const se = T();
      return Yl(
        k,
        f.value.format ?? h(),
        se ?? En({}, a.enableSeconds),
        a.inputValue,
        A.value,
        a.formatLocale
      );
    }, le = (k) => {
      const { rangeSeparator: se } = f.value, [u, re] = k.split(`${se}`);
      if (u) {
        const G = L(u.trim()), I = re ? L(re.trim()) : void 0;
        if (_t(G, I)) return;
        const x = G && I ? [G, I] : [G];
        F(I, x, 0) && (_.value = G ? x : null);
      }
    }, U = () => {
      A.value = !0;
    }, $ = (k) => {
      if (P.value.enabled)
        le(k);
      else if (v.value.enabled) {
        const se = k.split(";");
        _.value = se.map((u) => L(u.trim())).filter((u) => u);
      } else
        _.value = L(k);
    }, ee = (k) => {
      const se = typeof k == "string" ? k : k.target?.value;
      se !== "" ? (f.value.openMenu && !a.isMenuOpen && n("open"), $(se), n("set-input-date", _.value)) : z(), A.value = !1, n("update:input-value", se), n("text-input", k, _.value);
    }, O = (k) => {
      f.value.enabled ? ($(k.target.value), f.value.enterSubmit && za(_.value) && a.inputValue !== "" ? (n("set-input-date", _.value, !0), _.value = null) : f.value.enterSubmit && a.inputValue === "" && (_.value = null, n("clear"))) : pe(k);
    }, J = (k, se) => {
      f.value.enabled && f.value.tabSubmit && !se && $(k.target.value), f.value.tabSubmit && za(_.value) && a.inputValue !== "" ? (n("set-input-date", _.value, !0, !0), _.value = null) : f.value.tabSubmit && a.inputValue === "" && (_.value = null, n("clear", !0));
    }, ce = () => {
      M.value = !0, n("focus"), at().then(() => {
        f.value.enabled && f.value.selectOnFocus && C.value?.select();
      });
    }, pe = (k) => {
      if (Dt(k, d.value, !0), f.value.enabled && f.value.openMenu && !g.value.input) {
        if (f.value.openMenu === "open" && !a.isMenuOpen) return n("open");
        if (f.value.openMenu === "toggle") return n("toggle");
      } else f.value.enabled || n("toggle");
    }, p = () => {
      n("real-blur"), M.value = !1, (!a.isMenuOpen || g.value.enabled && g.value.input) && n("blur"), a.autoApply && f.value.enabled && _.value && !a.isMenuOpen && (n("set-input-date", _.value), n("select-date"), _.value = null);
    }, Y = (k) => {
      Dt(k, d.value, !0), n("clear");
    }, te = () => {
      n("close");
    }, y = (k) => {
      if (k.key === "Tab" && J(k), k.key === "Enter" && O(k), k.key === "Escape" && f.value.escClose && te(), !f.value.enabled) {
        if (k.code === "Tab") return;
        k.preventDefault();
      }
    }, V = () => {
      C.value?.focus({ preventScroll: !0 });
    }, S = (k) => {
      _.value = k;
    }, q = (k) => {
      k.key === Re.tab && J(k, !0);
    };
    return t({
      focusInput: V,
      setParsedDate: S
    }), (k, se) => (w(), W("div", { onClick: pe }, [
      k.$slots.trigger && !k.$slots["dp-input"] && !s(g).enabled ? ie(k.$slots, "trigger", { key: 0 }) : Q("", !0),
      !k.$slots.trigger && (!s(g).enabled || s(g).input) ? (w(), W("div", go, [
        k.$slots["dp-input"] && !k.$slots.trigger && (!s(g).enabled || s(g).enabled && s(g).input) ? ie(k.$slots, "dp-input", {
          key: 0,
          value: e.inputValue,
          isMenuOpen: e.isMenuOpen,
          onInput: ee,
          onEnter: O,
          onTab: J,
          onClear: Y,
          onBlur: p,
          onKeypress: y,
          onPaste: U,
          onFocus: ce,
          openMenu: () => k.$emit("open"),
          closeMenu: () => k.$emit("close"),
          toggleMenu: () => k.$emit("toggle")
        }) : Q("", !0),
        k.$slots["dp-input"] ? Q("", !0) : (w(), W("input", {
          key: 1,
          id: k.uid ? `dp-input-${k.uid}` : void 0,
          ref_key: "inputRef",
          ref: C,
          "data-test-id": "dp-input",
          name: k.name,
          class: De(m.value),
          inputmode: s(f).enabled ? "text" : "none",
          placeholder: k.placeholder,
          disabled: k.disabled,
          readonly: k.readonly,
          required: k.required,
          value: e.inputValue,
          autocomplete: k.autocomplete,
          "aria-label": s(i)?.input,
          "aria-disabled": k.disabled || void 0,
          "aria-invalid": k.state === !1 ? !0 : void 0,
          onInput: ee,
          onBlur: p,
          onFocus: ce,
          onKeypress: y,
          onKeydown: se[0] || (se[0] = (u) => y(u)),
          onPaste: U
        }, null, 42, yo)),
        he("div", {
          onClick: se[3] || (se[3] = (u) => n("toggle"))
        }, [
          k.$slots["input-icon"] && !k.hideInputIcon ? (w(), W("span", {
            key: 0,
            class: "dp__input_icon",
            onClick: se[1] || (se[1] = (u) => n("toggle"))
          }, [
            ie(k.$slots, "input-icon")
          ])) : Q("", !0),
          !k.$slots["input-icon"] && !k.hideInputIcon && !k.$slots["dp-input"] ? (w(), Te(s(jt), {
            key: 1,
            "aria-label": s(i)?.calendarIcon,
            class: "dp__input_icon dp__input_icons",
            onClick: se[2] || (se[2] = (u) => n("toggle"))
          }, null, 8, ["aria-label"])) : Q("", !0)
        ]),
        k.$slots["clear-icon"] && (k.alwaysClearable || e.inputValue && k.clearable && !k.disabled && !k.readonly) ? (w(), W("span", ho, [
          ie(k.$slots, "clear-icon", { clear: Y })
        ])) : Q("", !0),
        !k.$slots["clear-icon"] && (k.alwaysClearable || k.clearable && e.inputValue && !k.disabled && !k.readonly) ? (w(), W("button", {
          key: 3,
          "aria-label": s(i)?.clearInput,
          class: "dp--clear-btn",
          type: "button",
          onKeydown: se[4] || (se[4] = (u) => s(qe)(u, () => Y(u), !0, q)),
          onClick: se[5] || (se[5] = Xt((u) => Y(u), ["prevent"]))
        }, [
          tt(s(Sn), {
            class: "dp__input_icons",
            "data-test-id": "clear-icon"
          })
        ], 40, bo)) : Q("", !0)
      ])) : Q("", !0)
    ]));
  }
}), wo = typeof window < "u" ? window : void 0, Ea = () => {
}, Do = (e) => al() ? (nl(e), !0) : !1, Mo = (e, t, l, n) => {
  if (!e) return Ea;
  let a = Ea;
  const f = rt(
    () => s(e),
    (g) => {
      a(), g && (g.removeEventListener(t, l), g.addEventListener(t, l, n), a = () => {
        g.removeEventListener(t, l, n), a = Ea;
      });
    },
    { immediate: !0, flush: "post" }
  ), i = () => {
    f(), a();
  };
  return Do(i), i;
}, $o = (e, t, l, n = {}) => {
  const { window: a = wo, event: f = "pointerdown" } = n;
  return a ? Mo(a, f, (g) => {
    const d = Le(e), P = Le(t);
    !d || !P || d === g.target || g.composedPath().includes(d) || g.composedPath().includes(P) || l(g);
  }, { passive: !0 }) : void 0;
}, Ao = ["data-dp-mobile"], To = /* @__PURE__ */ We({
  compatConfig: {
    MODE: 3
  },
  __name: "VueDatePicker",
  props: {
    ...va
  },
  emits: [
    "update:model-value",
    "update:model-timezone-value",
    "text-submit",
    "closed",
    "cleared",
    "open",
    "focus",
    "blur",
    "internal-model-change",
    "recalculate-position",
    "flow-step",
    "update-month-year",
    "invalid-select",
    "invalid-fixed-range",
    "tooltip-open",
    "tooltip-close",
    "time-picker-open",
    "time-picker-close",
    "am-pm-change",
    "range-start",
    "range-end",
    "date-update",
    "invalid-date",
    "overlay-toggle",
    "text-input"
  ],
  setup(e, { expose: t, emit: l }) {
    const n = l, a = e, f = Yt(), i = Z(!1), g = qt(a, "modelValue"), d = qt(a, "timezone"), P = Z(null), v = Z(null), R = Z(null), h = Z(!1), T = Z(null), F = Z(!1), _ = Z(!1), C = Z(!1), M = Z(!1), { setMenuFocused: A, setShiftKey: m } = Hn(), { clearArrowNav: z } = At(), { validateDate: L, isValidTime: le } = Tt(a), {
      defaultedTransitions: U,
      defaultedTextInput: $,
      defaultedInline: ee,
      defaultedConfig: O,
      defaultedRange: J,
      defaultedMultiDates: ce
    } = Oe(a), { menuTransition: pe, showTransition: p } = aa(U), { isMobile: Y } = Qn(O), te = ll();
    Ue(() => {
      x(a.modelValue), at().then(() => {
        ee.value.enabled || (u(T.value)?.addEventListener("scroll", K), window?.addEventListener("resize", oe));
      }), ee.value.enabled && (i.value = !0), window?.addEventListener("keyup", ge), window?.addEventListener("keydown", _e);
    }), Ut(() => {
      ee.value.enabled || (u(T.value)?.removeEventListener("scroll", K), window?.removeEventListener("resize", oe)), window?.removeEventListener("keyup", ge), window?.removeEventListener("keydown", _e);
    });
    const y = et(f, "all", a.presetDates), V = et(f, "input");
    rt(
      [g, d],
      () => {
        x(g.value);
      },
      { deep: !0 }
    );
    const { openOnTop: S, menuStyle: q, xCorrect: k, setMenuPosition: se, getScrollableParent: u, shadowRender: re } = co({
      menuRef: P,
      menuRefInner: v,
      inputRef: R,
      pickerWrapperRef: T,
      inline: ee,
      emit: n,
      props: a,
      slots: f
    }), {
      inputValue: G,
      internalModelValue: I,
      parseExternalModelValue: x,
      emitModelValue: c,
      formatInputValue: o,
      checkBeforeEmit: X
    } = rr(n, a, { isInputFocused: h, isTextInputDate: M }), B = j(
      () => ({
        dp__main: !0,
        dp__theme_dark: a.dark,
        dp__theme_light: !a.dark,
        dp__flex_display: ee.value.enabled,
        "dp--flex-display-collapsed": C.value,
        dp__flex_display_with_input: ee.value.input
      })
    ), be = j(() => a.dark ? "dp__theme_dark" : "dp__theme_light"), Ae = j(() => a.teleport ? {
      to: typeof a.teleport == "boolean" ? "body" : a.teleport,
      disabled: !a.teleport || ee.value.enabled
    } : {}), ne = j(() => ({ class: "dp__outer_menu_wrap" })), r = j(() => ee.value.enabled && (a.timePicker || a.monthPicker || a.yearPicker || a.quarterPicker)), E = () => R.value?.$el?.getBoundingClientRect() ?? { width: 0, left: 0, right: 0 }, K = () => {
      i.value && (O.value.closeOnScroll ? Xe() : se());
    }, oe = () => {
      i.value && se();
      const N = v.value?.$el.getBoundingClientRect().width ?? 0;
      C.value = document.body.offsetWidth <= N;
    }, ge = (N) => {
      N.key === "Tab" && !ee.value.enabled && !a.teleport && O.value.tabOutClosesMenu && (T.value.contains(document.activeElement) || Xe()), _.value = N.shiftKey;
    }, _e = (N) => {
      _.value = N.shiftKey;
    }, Ye = () => {
      !a.disabled && !a.readonly && (re(te, hn, a), se(!1), i.value = !0, i.value && n("open"), i.value || xe(), x(a.modelValue));
    }, nt = () => {
      G.value = "", xe(), v.value?.onValueCleared(), R.value?.setParsedDate(null), n("update:model-value", null), n("update:model-timezone-value", null), n("cleared"), O.value.closeOnClearValue && Xe();
    }, St = () => {
      const N = I.value;
      return !N || !Array.isArray(N) && L(N) ? !0 : Array.isArray(N) ? ce.value.enabled || N.length === 2 && L(N[0]) && L(N[1]) ? !0 : J.value.partialRange && !a.timePicker ? L(N[0]) : !1 : !1;
    }, D = () => {
      X() && St() ? (c(), Xe()) : n("invalid-select", I.value);
    }, de = (N) => {
      fe(), c(), O.value.closeOnAutoApply && !N && Xe();
    }, fe = () => {
      R.value && $.value.enabled && R.value.setParsedDate(I.value);
    }, ht = (N = !1) => {
      a.autoApply && le(I.value) && St() && (J.value.enabled && Array.isArray(I.value) ? (J.value.partialRange || I.value.length === 2) && de(N) : de(N));
    }, xe = () => {
      $.value.enabled || (I.value = null);
    }, Xe = (N = !1) => {
      N && I.value && O.value.setDateOnMenuClose && D(), ee.value.enabled || (i.value && (i.value = !1, k.value = !1, A(!1), m(!1), z(), n("closed"), G.value && x(g.value)), xe(), n("blur"), v.value?.$el?.remove());
    }, ya = (N, ue, me = !1) => {
      if (!N) {
        I.value = null;
        return;
      }
      const vt = Array.isArray(N) ? !N.some((Pt) => !L(Pt)) : L(N), ct = le(N);
      vt && ct ? (M.value = !0, I.value = N, ue ? (F.value = me, D(), n("text-submit")) : a.autoApply && ht(!0), at().then(() => {
        M.value = !1;
      })) : n("invalid-date", N);
    }, ha = () => {
      a.autoApply && le(I.value) && c(), fe();
    }, la = () => i.value ? Xe() : Ye(), ba = (N) => {
      I.value = N;
    }, ka = () => {
      $.value.enabled && (h.value = !0, o()), n("focus");
    }, wa = () => {
      $.value.enabled && (h.value = !1, x(a.modelValue), F.value && Ol(T.value, _.value)?.focus()), n("blur");
    }, Da = (N) => {
      v.value && v.value.updateMonthYear(0, {
        month: dn(N.month),
        year: dn(N.year)
      });
    }, Ma = (N) => {
      x(N ?? a.modelValue);
    }, an = (N, ue) => {
      v.value?.switchView(N, ue);
    }, b = (N, ue) => O.value.onClickOutside ? O.value.onClickOutside(N, ue) : Xe(!0), ae = (N = 0) => {
      v.value?.handleFlow(N);
    }, ve = () => P;
    return $o(
      P,
      R,
      (N) => b(St, N)
    ), t({
      closeMenu: Xe,
      selectDate: D,
      clearValue: nt,
      openMenu: Ye,
      onScroll: K,
      formatInputValue: o,
      // exposed for testing purposes
      updateInternalModelValue: ba,
      // modify internal modelValue
      setMonthYear: Da,
      parseModel: Ma,
      switchView: an,
      toggleMenu: la,
      handleFlow: ae,
      getDpWrapMenuRef: ve
    }), (N, ue) => (w(), W("div", {
      ref_key: "pickerWrapperRef",
      ref: T,
      class: De(B.value),
      "data-datepicker-instance": "",
      "data-dp-mobile": s(Y)
    }, [
      tt(ko, He({
        ref_key: "inputRef",
        ref: R,
        "input-value": s(G),
        "onUpdate:inputValue": ue[0] || (ue[0] = (me) => ln(G) ? G.value = me : null),
        "is-menu-open": i.value
      }, N.$props, {
        onClear: nt,
        onOpen: Ye,
        onSetInputDate: ya,
        onSetEmptyDate: s(c),
        onSelectDate: D,
        onToggle: la,
        onClose: Xe,
        onFocus: ka,
        onBlur: wa,
        onRealBlur: ue[1] || (ue[1] = (me) => h.value = !1),
        onTextInput: ue[2] || (ue[2] = (me) => N.$emit("text-input", me))
      }), Ge({ _: 2 }, [
        Ce(s(V), (me, vt) => ({
          name: me,
          fn: we((ct) => [
            ie(N.$slots, me, ze(Je(ct)))
          ])
        }))
      ]), 1040, ["input-value", "is-menu-open", "onSetEmptyDate"]),
      (w(), Te(fa(N.teleport ? rl : "div"), ze(Je(Ae.value)), {
        default: we(() => [
          tt(Vt, {
            name: s(pe)(s(S)),
            css: s(p) && !s(ee).enabled
          }, {
            default: we(() => [
              i.value ? (w(), W("div", He({
                key: 0,
                ref_key: "dpWrapMenuRef",
                ref: P
              }, ne.value, {
                class: { "dp--menu-wrapper": !s(ee).enabled },
                style: s(ee).enabled ? void 0 : s(q)
              }), [
                tt(hn, He({
                  ref_key: "dpMenuRef",
                  ref: v
                }, N.$props, {
                  "internal-model-value": s(I),
                  "onUpdate:internalModelValue": ue[3] || (ue[3] = (me) => ln(I) ? I.value = me : null),
                  class: { [be.value]: !0, "dp--menu-wrapper": N.teleport },
                  "open-on-top": s(S),
                  "no-overlay-focus": r.value,
                  collapse: C.value,
                  "get-input-rect": E,
                  "is-text-input-date": M.value,
                  onClosePicker: Xe,
                  onSelectDate: D,
                  onAutoApply: ht,
                  onTimeUpdate: ha,
                  onFlowStep: ue[4] || (ue[4] = (me) => N.$emit("flow-step", me)),
                  onUpdateMonthYear: ue[5] || (ue[5] = (me) => N.$emit("update-month-year", me)),
                  onInvalidSelect: ue[6] || (ue[6] = (me) => N.$emit("invalid-select", s(I))),
                  onAutoApplyInvalid: ue[7] || (ue[7] = (me) => N.$emit("invalid-select", me)),
                  onInvalidFixedRange: ue[8] || (ue[8] = (me) => N.$emit("invalid-fixed-range", me)),
                  onRecalculatePosition: s(se),
                  onTooltipOpen: ue[9] || (ue[9] = (me) => N.$emit("tooltip-open", me)),
                  onTooltipClose: ue[10] || (ue[10] = (me) => N.$emit("tooltip-close", me)),
                  onTimePickerOpen: ue[11] || (ue[11] = (me) => N.$emit("time-picker-open", me)),
                  onTimePickerClose: ue[12] || (ue[12] = (me) => N.$emit("time-picker-close", me)),
                  onAmPmChange: ue[13] || (ue[13] = (me) => N.$emit("am-pm-change", me)),
                  onRangeStart: ue[14] || (ue[14] = (me) => N.$emit("range-start", me)),
                  onRangeEnd: ue[15] || (ue[15] = (me) => N.$emit("range-end", me)),
                  onDateUpdate: ue[16] || (ue[16] = (me) => N.$emit("date-update", me)),
                  onInvalidDate: ue[17] || (ue[17] = (me) => N.$emit("invalid-date", me)),
                  onOverlayToggle: ue[18] || (ue[18] = (me) => N.$emit("overlay-toggle", me)),
                  onMenuBlur: ue[19] || (ue[19] = (me) => N.$emit("blur"))
                }), Ge({ _: 2 }, [
                  Ce(s(y), (me, vt) => ({
                    name: me,
                    fn: we((ct) => [
                      ie(N.$slots, me, ze(Je({ ...ct })))
                    ])
                  }))
                ]), 1040, ["internal-model-value", "class", "open-on-top", "no-overlay-focus", "collapse", "is-text-input-date", "onRecalculatePosition"])
              ], 16)) : Q("", !0)
            ]),
            _: 3
          }, 8, ["name", "css"])
        ]),
        _: 3
      }, 16))
    ], 10, Ao));
  }
}), qn = /* @__PURE__ */ (() => {
  const e = To;
  return e.install = (t) => {
    t.component("Vue3DatePicker", e);
  }, e;
})(), So = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: qn
}, Symbol.toStringTag, { value: "Module" }));
Object.entries(So).forEach(([e, t]) => {
  e !== "default" && (qn[e] = t);
});
export {
  qn as default
};
